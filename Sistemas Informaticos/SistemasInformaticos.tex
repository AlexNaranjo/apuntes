\documentclass{apuntes}

\title{Sistemas Informáticos}
\author{Elena Gutiérrez y Pedro Valero}
\date{14/15 C1}

% Paquetes adicionales

% --------------------

\begin{document}
\pagestyle{plain}
\maketitle

\tableofcontents
\newpage
\setcounter{chapter}{1}
\chapter{Sistemas distribuidos basados en la WWW}

Las partes 1 y 2 de este tema se consideran demasiado triviales y se deja como ejercicio para el lector el leerse los apuntes y haber realizado las prácticas. (Son las que hablan del XML, XSL y esas cosillas).

\setcounter{section}{2}
\section{Web interactiva (Aplicaciones Web)}
El modelo de Web hipertexto no permitía más iteracción del usuario que seleccionar la URL y comienzó a hacerse necesario establecer comunicación entre programas del servidor con datos que proporciona el usuario, ya sea por medio de formularios (forms) o mediante la ejecución de programas en el propio servidor (Common Gateway Interface, CGI)

\subsection{CGIs}
\begin{defn}[CGI]
El CGI es un programa que recibe informacion de un servidor HTTP o WWW, de modo que permite al servidor ejecutar programas externos y recoger informacion que posteriormente enviara al cliente por medio de paginas HTML y el protocolo HTTP. 
\end{defn}

Esta tecnología de la World Wide Web (es una extensión del protocolo HTTP) permite que un cliente (el navegador) pueda solicitar los datos de un programa ejecutado en un servidor web. Fueron de los primeras métodos para crear contenido dinámico para las páginas web. El servidor web pasa las solicitudes del cliente a un programa externo, el CGI  (éste suele estar escrito en lenguaje script), y la salida de este programa es enviada al cliente en lugar del archivo estático tradicional.

\textbf{Forma esquemática de actualización de un CGI}
\begin{enumerate}
\item El servidor recibe una petición por parte del cliente que activa un URL que contiene el CGI
\item El servidor prepara el entorno para ejecutar la aplicación. La información necesaria procede en su mayoría del cliente (el formulario de entrada). EL servidor también envía a la aplicación, información de origen, URL que el usuario solicita, protocolo utilizado, etc. El paso de información a través del CGI se realiza mediante variables de entorno, línea de comandos y entrada y salida estándar (stdin y stdout). Los nombres de las variables de entorno pueden ser específicos del sistema. Hay diferentes tipos de variables de entorno:
\begin{itemize}
\item Variables de entorno independientes de la petición.
\item Variables de entorno dependientes de la consulta en cuestión
\item Variables de entorno relacionadas con la seguridad de acceso.
\item Variables de entorno sobre info adicionan de la consulta
\item Variables de entorno de la cabecera HTTP.
\end{itemize}
\item El  servidor ejecuta la aplicación y captura la salida estándar.
\item La aplicación realiza su función y como resultado va generando un objeto MIME que la aplicación escribe en su salida estándar.
\item El servidor envía la información producida junto con la información propia del cliente. Es responsabilidad de la aplicación informar del objeto MIME que se genera.

\end{enumerate}
\textbf{Importante} : Toda la comunicacion se realiza mediante el protocolo HTTP y el uso de páginas HTML, pues muestran el resultado de la ejecución del programa del CGI.



\subsubsection{Ventajas e inconvenientes}
\textbf{Ventajas:}
\begin{itemize}
\item Sencillez de programación.
\item Permite el uso de cualquier lenguaje de programación (normalmente PERL e interpretados)
\item El programa CGI no puede afectar al funcionamiento del servidor por ejecutarse como un proceso independiente.
\item Estándar, de modo que generaliza la portabilidad entre servidores de distintos fabricantes.
\end{itemize}
\textbf{Inconvenientes:}
\begin{itemize}
\item Lento. Cada ejecucion requiere iniciar un proceso y termianrlo: reservas de memoria, apertura de ficheros, conexiones a bases de datos...
\item Funciona por sesiones de modo que el programa CGI termina con cada llamada y no mantiene el estado de la comunicación entre peticiones.
\end{itemize}


\subsection{Formularios}
A continuacion, una breve introduccion a los formularios HTML :
\subsubsection{Protocolos}
HTTP + páginas HTML

\subsubsection{Funcionamiento básico}
\begin{enumerate}
\item El cliente solicita la página al servidor web.
\item El servidor envía una página que contiene el formulario.
\item El cliente lo rellena y lo devuelve al servidor.
\item El servidor, por la URL que el cliente solicita, ejecuta el programa al que pasa los datos recibidos del cliente.
\item El programa genera una página con los resultados de su ejecución y la devuelve al cliente a través del servidor web.
\end{enumerate}

\subsubsection{Estructura y sintaxis}
La estructura de un formulario es la que sigue:
\begin{verbatim}
<FORM ACTION=url METHOD=método de envío>
  <INPUT> | <TEXTAREA> | <SELECT> | <BUTTON>
  otros elementos HTML
</FORM>
\end{verbatim}

Veamos con un poco más de detalle cuál es la función de cada campo del formulario:
\begin{itemize}
\item \textbf{Action:} Aquí se especifica la URL que se debe solicitar al enviar el formulario.
\item \textbf{Method:} Metodo de envio de los datos asociados al formulario. Pueden viajar asociados a la URL que se pide o en el cuerpo del mensaje HTTP.
\item Si \textbf{METHOD = GET} el mensaje HHTP es:
\begin{verbatim}
GET /logon?usuario=Superman&clave=loislane&nuevo=si
HTTP/1.1
(otras cabeceras HTTP)
(línea en blanco).
\end{verbatim}
\newpage
\item Si \textbf{METHOD = POST}, el mensaje habría sido:
\begin{verbatim}
POST /logon HTTP/1.1
CONTENT-TYPE: application/x-www-form-urlencoded
CONTENT-LENGT: xxx
(otras cabeceras HTTP)
(línea en blanco)
usuario=Superman&clave=loislane&nuevo=s
\end{verbatim}
\end{itemize}
\textbf{Importante} La diferencia básica entre GET y POST radica en la forma en la que se envian los datos desde el cliente, una vez que este ha rellenado el formulario, al servidor.

Usando el metodo GET indicamos que los datos se envian usando la URL. Esta consta de la direccion web seguido del simbolo ? y a continuacion parejas de datos nombre y valor (ahora separado cada par por el simbolo \&) que corresponden con los parametros que han sido rellenados por el cliente. A veces, ciertos caracteres introducidos en el form son sustituidos por otros en la URL. No olvidemos que una URL es una ruta a un recurso en otra máquina de modo que tenemos restricciones en cuanto a los nombres de los ficheros y carpetas a los que accedemos.

Usando el metodo POST, la informacion introducida por el cliente en el form viaja 'oculta', pues no la podemos ver en la URL.

\textbf{Comparando ambas}: El método POST exige el uso de otras tecnicas, como el lenguaje que posteriormente estudiaremos, PHP para recuperar los datos que el cliente introdujo en el form, mientras que usando GET podemos extraerlos directamente de a URL. Por otra parte, la ventaja de usar POST es que los datos no son visibles al usuario de la web, de modo que, en el caso de usar GET el usuario es capaz de modificar los parametros a traves de la URL puediendo modificar la informacion que el servidor tratará.

\section{Web Application Programming Interfaces (Web APIs)}
\subsection{Introducción}
\begin{defn}[API]
Una \textbf{API} es una interfaz de programación de aplicaciones (del inglés API: Application Programming Interface). Es un conjunto de rutinas que provee acceso a funciones de un determinado software.
\end{defn}

Son publicadas por los constructores de software para permitir acceso a características de bajo nivel o propietarias, detallando sólamente la forma en que cada rutina debe ser llevada a cabo y la funcionalidad que brinda, sin otorgar información acerca de cómo se lleva a cabo la tarea. Son utilizadas por los programadores para construir sus aplicaciones sin necesidad de volver a programar funciones ya hechas por otros, reutilizando código que se sabe que está probado y que funciona correctamente.

En la web, las API's son publicadas por sitios (\emph{websites}) para brindar la posibilidad de realizar alguna acción o acceder a alguna característica o contenido que el sitio provee. Algunas de las más conocidas son las API's de: Google Maps, Amazon, Flickr, Google Search,...

Surgen para mitigar el bajo rendimiento de la interfaz CGI. En este caso, los nuevos programas se enlazan junto con el servidor en una librería dinámica. El servidor llama a las funciones de la librería como tareas dentro del proceso servidor. El proceso, en este caso, no finaliza: se mantienen ficheros abiertos, conexiones a base de datos y demás entre las llamadas. Se proporciona una API de acceso a datos y estado del servidor.

Presenta inconvenientes. Un fallo en una rutina hace que pueda caer el servidor completo. Se hace uso de lenguajes como C, C++, que en este aspecto están limitados. Difícil de programar, pues es necesario conocer el funcionamiento del servidor para aprovecharlas al máximo.

Algunos ejemplos: Netscape (NSAPI), Microsoft (ISAPI), IBM (ICAPI, GWAPI)...

\subsection{Interfaces Híbridas:}
Tratan de evitar los inconvenientes que veíamos de las CGIs y las Web APIs.
Los programas se realizan independientemente del servidor Web y en cualquier lenguaje.
El servidor durante la inicialización puede arrancar los programas en procesos diferentes.
Los programas se inicializan antes de recibir la petición, y quedan a la espera de recibirlas.

Ya no hay comunicación por medio de variables de entorno, Se utilizarán mecanismos de comunicación entre procesos más rápidos como acceso remoto mediante mecanismos de comunicación o bien empleando los mismos elementos que empleaban los CGIs para facilitar la migración de programas CGI a nuevas interfaces.
Es posible mantener el estado de la aplicación entre peticiones sucesivas y una vez que la petición es atendida, el programa vuelve a esperar otra petición.

Ejemplos:
\begin{itemize}
\item FastCGI, de Open Market, Inc. Comunicación Servidor - Programas por Sockets.
\item Netscape Web Application Interface (WAI). Comunicación mediante CORBA.
\end{itemize}

\subsection{Páginas dinámicas:}
Se trata de extensiones del lenguaje HTML para permitir mayor capacidad de proceso. En el cliente (client side scripts) se lleva a cabo la inclusión de código que el cliente interpretará para variar dinámicamente la presentación de la página, proporcionando así “inteligencia” al navegador. En el servidor (server side scripts) se realiza una inclusión de código en el fichero que contiene la descripción de la página. De este modo, el servidor lo interpretará para variar la generación de la página antes de su envío al cliente.

Se trata de una alternativa a la programación CGI.

\section{El lenguaje PHP}
\subsection{Introducción}
Se trata de un lenguaje de programación basado en \emph{script} interpretado por el servidor. Presenta una sintaxis parecida a C y C++ y permite acceso a formularios, archivos, bases de datos, etc.

PHP es un lenguaje de script del lado del servidor (similar a otros lenguajes como ASP, JSP o Coldfusion). Sus siglas significan PHP Hypertext Processor. Los scripts PHP estan incrustados en el codigo HTML y el servidor los interpreta y ejecuta y transforma en HTML,  de modo que, el resultado que recibe el cliente no contiene código PHP. Es software abierto y gratuito, Para permitir el acceso a bases de datos, tenemos PHP + [PostgreSQL, MySQL], que es multiplataforma.


Para el acceso a información propia del servidor se utiliza un  array indexado con el nombre del parámetro al que se desea acceder. El nombre del array es \$\_SERVER[indice] donde índice puede ser: QUERY\_STRING, REMOTE\_HOST,....

Existen otros arrays indexados como \$\_REQUEST, para el acceso a variables asociadas a la petición recibida (campos de un formulario)
También existe \$\_SESSION que permite acceder a información de la sesión del usuario. El array \$\_REQUEST, tras una petición del cliente, incluye los contenidos de tres tipos de variables:
\begin{itemize}
\item \$\_GET Parámetros recibidos en un comando HTTP GET
\item \$\_POST Parámetros recibidos en un comando HTTP POST
\item \$\_COOKIES Lista de cookies recibidas con la petición.
\end{itemize}

Otras variables ya definidas son:
\begin{itemize}
\item\$\_FILES
\item\$\_ENV
\item\$\_GLOBALS
\end{itemize}


\subsection{Características del lenguaje}

\begin{verbatim}
$variable : Permite declarar variables. (Recuerda: es case sensitive). Ha de
 comenzar por letra o _ y después letras, números o _ (Recordemos el examen
  de AUTLEN). En  cuanto a su ámbito, son globales al fichero, excepto si
   aparecen en una función , que son locales.


echo $variable1 . $variable2: Permite concatenar cadenas e imprimirlas.


echo strpos("Hello world!","world") : Devuelve la posición en la que
 comienza la cadena que es el segundo argumento.


echo strlen("Hello world!");: Devuelve la longitud de la cadena (no cuenta /0)
\end{verbatim}



Veamos un ejemplo de declaración de una función:
\begin{verbatim}
function functionName()
{
  code to be executed;
}
\end{verbatim}

Ejemplo de declaración y uso de arrays:
\begin{verbatim}
$cars=array("Saab","Volvo","BMW","Toyota");
<?php
  $cars[0]="Saab";
  $cars[1]="Volvo";
  $cars[2]="BMW";
  $cars[3]="Toyota";
  echo $cars[0] . " and " . $cars[1] . " are Swedish cars.";
?>
\end{verbatim}
Resultado: Saab and Volvo are Swedish cars.

Ejemplo de declaración y uso de arrays \textbf{ASOCIATIVOS}
\begin{verbatim}
$ages = array("Peter"=>32, ”Mike"=>30, "Joe"=>34);
<?php
  $ages['Peter'] = "32";
  $ages['Mike'] = "30";
  $ages['Joe'] = "34";
  echo "Peter is " . $ages['Peter'] . " years old.";
?>
\end{verbatim}
Resultado: Peter is 32 years old.

\subsection{Tipos de datos en PHP}
PHP soporta 8 tipos de datos primitivos:
\begin{itemize}
\item Escalares: boolean, integer, double y string.
\item Compuestos: Array y object
\item Especiales: resource y NULL.
\end{itemize}
El tipo de dato no se suele especificar, sino que es en tiempo de ejecución cuando se determina en función del contexto. En este aspecto, algunas funciones interesantes son:
\begin{itemize}
\item gettype() que devuelve el tipo de una variable.
\item istype() por ejemplo: is\_array(), is\_float(), is\_null(), is\_numeric(), is\_scalar()..
\item var\_dump() muestra tipo y valor de una variable (interesa cuando usamos arrays).
\end{itemize}

\subsubsection{String}
Las cadenas pueden parecer entre comillas simples o dobles:
\begin{verbatim}
- Simples: admiten caracteres de escape como \’ (comilla simple) y \\ (barra).
Las variables no se expanden (es decir: ‘a vale $a’ muestra “a vale $a”)
- Dobles: admiten más caracteres de escape como \n, \r, \t, \\, \$, \”. En
 este caso, las variables sí se expanden: “a vale 9”
\end{verbatim}

Para acceder a un carácter de la cadena usamos: \$letra = \$cadena\{8\};

\textbf{Nota sobre la diferencia entre echo y print}:
Ambas permiten imprimir con salida en el fichero HTML que el servidor genera. ¿La diferencia? Son basicamente 2:
\begin{itemize}
\item echo es más rapido pues no devuleve un valor a diferencia de print
\item echo acepta el formato : echo expresion, [expresion], [expresion] mientras que print solo acepta el formato print([expresion]).
\end{itemize}
\textbf{Nota}: PHP es mas eficiente en el parseo de código si usamos comillas simples en lugar de dobles cuando la cadena que deseamos imprimir no contiene variables.



\subsubsection{Constantes}
Se definen así:
\begin{verbatim}
define (“CONSTANTE”, “hola); es decir define (“NOMBRE“, “valor”).
\end{verbatim}
No llevan \$ delante y solo se pueden definir constantes de tipo escalar: boolean, integer, string y double.

\newpage
\subsection{Funciones: Paso por referencia}
Si no indicamos nada los parámetros se pasan por valor.

Ejemplo:
\begin{verbatim}
function incrementa (&$a)
{
  $a = $a + 1;
}
$a=1;
incrementa ($a);
print $a; // Muestra un 2
\end{verbatim}

Ejemplo de función y array:

\begin{verbatim}
<HTML>
<HEAD>
  <TITLE>Fecha</TITLE>
  <?PHP
    // Función que obtiene el nombre de un mes
    function nombreMes ($mes)
    {
      $meses = array ("enero", "febrero", "marzo", "abril", "mayo",
      "junio", "julio", "agosto", "septiembre",
      "octubre", "noviembre", "diciembre");
      $i=0;
      $enc=false;
      while ($i<12 and !$enc)
      {
        if ($i == $mes-1)
        $enc = true;
        else
        $i++;
      }
      return ($meses[$i]);
    }
  ?>
</HEAD>
<BODY>
  <H1>Tablas y funciones</H1>
  <?PHP
    $dia = date ("j");
    $mes = date ("n");
    $anyo = date ("Y");
    print ("Hoy es " . $dia . " de " . nombreMes($mes) .
    " de " . $anyo . "<BR>\n");
  ?>
</BODY>
</HTML>
\end{verbatim}

\subsection{HTML + PHP: Formularios}
Si declaramos en el html un elemento form con el campo method = “GET” entonces en el código php (incluido en otro fichero a parte) debemos acceder a los campos input mediante: GET[“atributo”] donde “atributo” es el valor del campo name del elemento input.

Particularidades:
\begin{enumerate}
\item Si “atributo” era type = “text” : \$atributo = GET[“atributo”] guardará el texto que introdujimos.

\item Si “atributo” era type = “radio” : Haremos \$atributo = GET[“atributo”] que guardara el campo value de la opción que hayamos pinchado.

\item Si “atributo” era type = “checkbutton”  y por tanto name= valores[]: Haremos \$valores = GET[“valores”] que guardará en forma de array los valores que han sido marcados (y por tanto la longitud del array será igual al número de “tics” que hayan sido marcados). Podemos imprimirlos así:
\begin{verbatim}
$valores= $_GET['valores'];
$n = count ($valores);
for ($i=0; $i<$n; $i++)
  print ("$valores[$i]<BR>\n");
\end{verbatim}
y solo se imprimirán aquellos campos “value “ de los que fueron marcados.

\item Si “atributo” era de type=“button” guardaremos en \$atributo=\$\_GET[“atributo”] true or false (no se si eso exactamente pero el equivalente a esto en php). De este modo, tiene sentido poner:
\begin{verbatim}
if ($actualizar)
  print("Se han actualizado los datos");
\end{verbatim}
%\begin{obs} Este tipo no funciona igual que “submit”. En este último caso, podemos acceder al .php al que asociamos el formulario, sin embargo escribiendo button, aun poniendo la url en el campo action de form, no funciona?
%\end{obs}

\item Podemos usar de manera análoga: password, <SELECT AREA>, <SELECT MULTIPLE> <TEXTAREA>

\item Importante:
Una de las ventajas de PHP es que se puede procesar y mostrar el formulario desde un mismo .php. La estructura debe ser la siguiente:
\begin{verbatim}
si se ha enviado el formulario:
  si hay errores:
    Mostrar formulario con errores
  si no:
    Procesar formulario
si no:
  Mostrar formulario
\end{verbatim}
La clave para que esto funcione es indicar en el formulario que el campo action es el mismo php que en el que nos encontramos. Además para comprobar que se ha pulsado o no el botón de submit, debemos usar la condición:
if (isset(\$aceptar)) o bien if (\$aceptar==”Aceptar”) donde el elemento HTML tiene la forma:
\begin{verbatim}
<INPUT TYPE="SUBMIT" NAME="aceptar" VALUE="Aceptar">
\end{verbatim}

Para ver un ejemplo, mirar el ejercicio que se pidió subir a moodle.
\end{enumerate}

\subsection{Cookies}
Se trata de un pequeño fichero que el servidor introduce en el pc del cliente (con el permiso de su navegador). Cada vez que el navegador solicite una nueva página  a ese servidor, le enviará también la cookie.

\subsubsection{Sintaxis}
Se coloca antes de la etiqueta <html>
\begin{verbatim}
<?php
	setcookie("user", ”Bob Sponge", time() + 60 * 60);
?>
<html>
...
\end{verbatim}

La variable \$\_COOKIE es un array que guarda (name,value, expire, path, domain) que son los campos que se introducen en la función setcookie. Esta información es la que viaja en un fichero cada vez que se produce una comunicación entre el servidor y el cliente.

Para imprimirlos:

\begin{verbatim}
echo $_COOKIE[“user”];
\end{verbatim}
Para ver todas:
\begin{verbatim}
print_r($_COOKIE);
\end{verbatim}
Para verificar que una en concreto existe:
\begin{verbatim}
if(isset($_COOKIE[“user”]))....
\end{verbatim}

\subsection{Sesiones}
Por último, en PHP encontramos una variable que es \$\_SESSION que guarda valores relativos a la sesión que se tiene abierta. Es útil cuando el servidor quiere llevar el rastro del usuario durante un tiempo finito, por ejemplo, cuando el cliente visita varios lugares de un supermercado añadiendo productos a un carrito de la compra.

\subsubsection{Sintaxis}
Algunas de las funciones más importantes son:
\begin{itemize}
\item \textbf{session\_start()}; Comienza la sesión o la reanuda si ya existía.
\item \textbf{\$\_SESSION[‘name’] = “Elena”}; Establece el nombre o identificador  de la sesión
\item \textbf{unset(\$\_SESSION[‘name])}; Borra el identificador del usuario (elimina una única variable del array \$\_SESSION). Esta funcion puede ser aplicada a otras variables previamente declaradas en nuestro código y su comportamiento es destruir dicha variable. Ojo, si la variable en cuestión es global y llamamos a unset() dentro de una función, solo la variable local sera destruida.

 Otro ejemplo:
unset(\$\_SESSION['session\_var']);

\item \textbf{session\_unset()}; Borra los contenidos de la sesión pero mantiene el id y el nombre de la sesión.
\item \textbf{session\_destroy()}; Elimina la sesión (no sólo los datos que fueron guardados en la misma). Sería lo conveniente, cuando, por ejemplo, un usuario decide hacer \emph{log out} en una página web.
\end{itemize}

\section{Ejecución de código en el cliente: Javascript, AJAX y JQuery}

\subsection{Javascript}
\subsubsection{Introducción}
Es un lenguaje de programación interpretado, dialecto del estándar ECMAScript desarrollado por Netscape en colaboración con Sun. Se define como orientado a objetos, basado en prototipos, imperativo, débilmente tipado y dinámico.

Se utiliza principalmente en su forma del lado del cliente (client-side), implementado como parte de un navegador web permitiendo mejoras en la interfaz de usuario y páginas web dinámicas aunque existe una forma de JavaScript del lado del servidor (Server-side JavaScript o SSJS). 

JavaScript se diseñó con una sintaxis similar al C (permite la creación e invocación de rutinas en HTML ), aunque adopta nombres y convenciones del lenguaje de programación Java. Sin embargo Java y JavaScript no están relacionados y tienen semánticas y propósitos diferentes.

Todos los navegadores modernos interpretan el código JavaScript integrado en las páginas web. Para interactuar con una página web, se provee al lenguaje JavaScript de una implementación del Document Object Model(DOM).
JavaScript se interpreta en el agente de usuario, al mismo tiempo que las sentencias van descargándose junto con el código HTML.

\subsubsection{Aplicaciones}
 Su uso en aplicaciones externas a la web, por ejemplo en documentos PDF, aplicaciones de escritorio (mayoritariamente widgets) es también significativo. En cuanto a las más significativas:
\begin{itemize}
\item Inclusión de adornos y efectos visuales en textos e imágenes 
de las páginas web
\item Manipulación de contenidos de forma dinámica
\item Realización de operaciones matemáticas sencillas
\item Validación de datos introducidos en formularios
\item Gestión del sistema de navegación (menús desplegables)
\item Control del tipo y versión del navegador web, uso de la fecha y 
hora actuales, verificación de plugins…
\end{itemize}
Además proporciona objetos para manejar un documento HTML:
\begin{itemize}
\item Window \item Document \item Frame \item Location  \item Navigator \item History \item Button  \item Textarea \item Radio
\end{itemize}
Junto con funciones para capturar  eventos
\begin{itemize}
\item onClick \item onChange \item onFocus \item onLoad \item onMouseOver \item onSelect
 \end{itemize}
\subsubsection{Características}
Está enfocado al manejo de elementos de documentos HTML y el navegador web, minimizando el trasiego de datos entre el cliente y el servidor.

Permite realizar tareas sencillas que no requieren mucha más información que la proporcionada por el usuario a través del propio documento HTML sobre el que se ejecuta. No se compila sino que es \textbf{interpretado por el navegador} y aparece insertado en el código HTML.

Por comodidad, el código suele escribirse en la cabecera del docuemto HTML o en un fichero aparte, que será enviado junto con el HTML ante la solicitud de un cliente.

Es case-sensitive y las sentencias se terminan mediante ; o salto de línea.
\subsubsection{Variables}
\begin{enumerate}
\item Son 'no tipadas', es decir, no se declara el tipo de dato y, además, puede cambiar a lo largo de la ejecución de un programa.

Ejemplo:

\begin{verbatim}
x = 2 // El tipo de datos de x es entero, pero no se declara
x = "hola" // El tipo de x se puede cambiar
\end{verbatim}
\item Las variables son globales por defecto. Para declararlas locales:
\begin{verbatim}
var x;
 \end{verbatim}
\item Otros ejemplos:

\begin{verbatim}
x = 1.7 // Número
x = "hola" // Cadena de caracteres
x = 'hola' // Cadena de caracteres
x = 'hola ' + 'mundo' // Concatenación de cadenas de caracteres
x = true // Booleano
x = null // Literal nulo
x = [2, 3, 5, "Alice"] // Array, x[0], x[1], x[2], x[3]
x = \{ a:2, b:'Bob' \} // Array asociativo, x['a'], x['b']
\end{verbatim}
\end{enumerate}
\subsubsection{Objetos}
En este aspecto es muy similar a Java. Cada objeto consta de \textbf{ propiedades +  métodos ( + eventos)}. 
\begin{enumerate}
\item Propiedades
\begin{itemize}
\item Son las características (atributos y elemntos) de un objeto. 
\item Las propiedades pueden ser a su vez objetos. 
\item Para crear nuevos objetos y sus propeidades:
\begin{verbatim} 
 profesor = new Object(); 
profesor.nombre = ”Kowalski";
\end{verbatim}
\item Para acceder a sus propiedades una vez creadas:
\begin{verbatim} 
unaCadena.length; 
window.document;
\end{verbatim}
\end{itemize}

\item Métodos: 
\begin{itemize}
\item Son funcionalidades de las que consta un objeto.
\item Ejemplos:
\begin{verbatim} 
 unaCadena.substring(2);
 window.write('<p>Hola mundo</p>’);
\end{verbatim}

\end{itemize}
\item Eventos
\begin{itemize}
\item Son acciones que ocurren  en la interfaz gráfica sobre un objeto de la misma:
\begin{itemize}
\item Llevadas a cabo por el usuario (click del ratón o pulsación de una tecla,...) o,
\item Asociadas al documento (carga del contenido o maximixación/minimización de la ventana,... )
\end{itemize}
\item Desatan la ejecución de métodos.
\item Ejemplos:
\begin{verbatim} 
<input type="button" onClick="window.alert('¡Botón pulsado!')">
\end{verbatim}
\end{itemize}


En JavaScript existe un objeto llamado document, que engloba todo el fichero html. De él cuelgan, a modo de árbol, los diferentes elementos del documento:
\begin {itemize}
\item Layer
\item Link
\item Image
\item Area
\item Anchor
\item Applet
\item Plugin
\item Form
\end{itemize}
En particular, dentro de la clase Form de document encontramos las subclases:

\begin{itemize}
\item Textarea
\item Text
\item FileUpload
\item Password
\item Hidden
\item Submit
\item Reset
\item Radio
\item Checkbox
\item Button
\item Select
\end{itemize}

De este modo, un botón definido así:

\begin{verbatim}
<INPUT id=“botón submit" type="submit" >
\end{verbatim}
puede ser identificado en Javascript de las siguientes maneras:

document.forms[0].elements[3] (si es el cuarto elemento dentro de un formulario en HTML).

document.getElementById("botón submit")

document.getElementByTagName("input")[2]



\end{enumerate}

\subsection{Incorporacion de código Javascript en documentos HTML}

La integración de Javascript y HTML en el diseño de páginas web se puede hacer de 3 maneras:

\begin{enumerate}
\item Como código directo en el cuerpo de un documento HTML.
\item Incorporación de funciones en la cabecera del documento HTML.
\item Incorporación de código en forma de fucniones en un fichero de texto independiente (.js).
 
\end{enumerate}


A continuación presentamos un ejemplo de cada una de estras 3 modalidades:

1. Ejemplo de código directo:

\begin{verbatim}
<HTML>
<HEAD>
</HEAD>
<BODY>
<SCRIPT type="text/javascript">
document.write("<H1><U>Títulos</U><BR></H1>")
for (i=1; i<=6; i++) \{
document.write("<H" + i + ">Título " + i)
document.write("</H" + i + "><BR>")
\}
</SCRIPT>
</BODY>
</HTML
\end{verbatim}

3. Ejemplo de código en la cabecera de un documento HTML:

\begin{verbatim}
<HTML>
<HEAD>
<SCRIPT type="text/javascript">
function mostrarTitulos() \{
document.write("<H1><U>Títulos</U><BR></H1>")
for (i=1; i<=6; i++) \{
document.write("<H" + i + ">Título " + i)
document.write("</H" + i + "><BR>")
\}
\}
</SCRIPT>
</HEAD>
<BODY>
<INPUT type="button" value="Mostrar" onClick="mostrarTitulos()">
</BODY>
</HTML>
\end{verbatim}

1. Ejemplo de código en un fichero.js independiente:
En el documento HTML:
\begin{verbatim}
<HTML>
<HEAD>
<SCRIPT src="mostrar-titulos.js"></SCRIPT>
</HEAD>
<BODY>
<INPUT type="button" value="Mostrar" onClick="mostrarTitulos()">
</BODY>
</HTML>

\end{verbatim}

En el fichero independiente .js:
\begin{verbatim}
function mostrarTitulos() \{
document.write("<H1><U>Títulos</U><BR></H1>")
for (i=1; i<=6; i++)\{
document.write("<H" + i + ">Título " + i)
document.write("</H" + i + "><BR>")
\}
\}
\end{verbatim}

\textbf{Nota:} Los ejemplos 1-7 se dejan como ejercicios para el lector.

Para acabar con la sección del lenguaje Javascript, es importante saber que no todos los navegadores reconocen Javascript a día de hoy, veáse las versiones antiguas de nuestro navegador favorito : Internet Explorer. Es, por tanto, útil el uso del siguiente comentario en nuestros códigos Javascript para evitar que el código sea mostrado como parte del contenido de la página.

\begin{verbatim}
<html>
<body>
<script type="text/javascript">
<!--
document.getElementById("demo").innerHTML=Date();
//-->
</script>
</body>
</html>
\end{verbatim}

Damos comienzo a una nueva sección con las vertientes que surgieron de Javascript: \textbf{DHTML, AJAX y JQuery}. 

\subsection{DHTML }
Con el objetivo de aumentar la interactividad y la creatividad en las páginas web surgió DHTML. Se trata de un término que engloba una serie de tecnologías diseñadas para el enriquecimiento de las páginas web usando una combinación de lenguajes “etiquetados”, como por ejemplo, HTML; lenguaje de scripting del lado del cliente, como por ejemplo, Javascript; lenguaje de definición de estilo, como por ejemplo, CSS; y Document Object Model, esto es, DOM (se trata de un lenguaje independiente que permite la creación e interacción con objetos  HTML, XML, y  XHTML. Los nodos de este tipo de documentos se estructuran en forma de árbol recibiendo la estructura,  el nombre de DOM tree).


\subsection{AJAX}
Con fines de eficiencia y mejora de la usabilidad de las páginas web nace AJAX. 

\emph{Standing for} Asynchronous Javascript and XML, no se trata de un nuevo lenguaje de programación sino de una nueva forma de usar  la tecnología que disponemos. Se trata de una nueva técnica de desarrollo web para crear aplicaciones interactivas del lado del cliente o RIA (Rich Internet Applications), manteniendo comunicación asíncrona con el servidor en un segundo plano. Alcanzó popularidad con Google y actualmente permiten su uso Mozilla, Mozilla Firefox, navegadores basados en Webkit (¿Qué es esto? es una plataforma para aplicaciones que funciona como base para navegadores  navegador web Safari, Google Chrome entre otros) como Google Chrome de Google o Safari, Microsoft Internet Explorer  y superiores...

\textbf{¿Qué se gana con esto?}
Poder realizar cambios sobre las páginas sin necesidad de recargarlas mejorando así la interactividad, velocidad y usabilidad de las páginas web.

Es una tecnología asíncrona en el sentido de que los datos adicionales se solicita al servidor y se cargan en segundo plano sin interferir en la visualización ni el comportamiento de la página. JavaScript es el lenguaje interpretado (scripting language) en el que normalmente se efectúan las funciones de llamada de Ajax mientras que el acceso a los datos se realiza mediante XMLHttpRequest, objeto disponible en los navegadores actuales. En cualquier caso, no es necesario que el contenido asíncrono esté formateado en XML.
Ajax es una técnica válida para múltiples plataformas y utilizable en muchos sistemas operativos y navegadores dado que está basado en estándares abiertos como JavaScript y Document Object Model (DOM).

\textbf{¿Cómo funciona?}
Combina estándares de Internet:

– XMLHttpRequest object (¿Y esto qué es? es una interfaz empleada para realizar peticiones HTTP y HTTPS a servidores Web). Para los datos transferidos se usa cualquier codificación basada en texto, incluyendo: texto plano, XML, JSON, HTML y codificaciones particulares específicas. La interfaz se implementa como una clase de la que una aplicación cliente puede generar tantas instancias como necesite para manejar el diálogo con el servidor. Se trata del objeto clave para realizar las comunicaciones con el servidor desde un segundo plano  sin necesidad de recargar las páginas. Este objeto depende de cada navegador, teniendo una implementación y comportamiento distinto en navegadores obsoletos como Internet Explorer 6 y anteriores. Para su creación usamos los métodos: 
xmlhttp=new XMLHttpRequest();
xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");

– JavaScript/DOM
– CSS
– XML
Además las aplicaciones AJAX no dependen del navegador ni de la plataforma que utilicemos.



\subsubsection{Ventajas e Inconvenientes de AJAX}
\begin{enumerate}
\item Cuando realizamos varias peticiones sucesivas de AJAX y con ello creamos nuevas páginas dinámicas, éstas no son registradas de forma automática en el historial de nuestro navegador de modo que si pulsamos atrás el usuario no regresa a la página anterior con el estado anterior sino que puede ser llevado a la última página que visitó.

 ¿Solución? 

Incluir el uso de Iframes ( ¿Qué es esto?  Se trata de un elemento HTML que permite insertar o incrustar un HTML dentro de otro principal y que ya es aceptado por la W. Comparando con AJAX, este último hace que cada parte de un documento HTML sea independiente) para desencadenar cambios en el historial del navegador y el cambio de la porción de anclaje de la dirección (después de un \#).

\item Dependiendo de cómo  se desarrolle el sitio web puedes mejorar o empeorar la carga en el servidor. Ajax puede ayudar al servidor a evitar la  generación de HTML, dejándole ese trabajo al cliente, pero también puede sobrecargar al servidor si se hacen varias llamadas a Ajax.

\item Es posible que AJAX no funcione en teléfonos móviles y otros dispositivos.

\end{enumerate}
\subsubsection{Ejemplo de funcionamiento}
\small
\begin{verbatim}
<html>
  <head>
    <script type="text/javascript">
      function loadXMLDoc() {
        var xmlhttp;
         if (window.XMLHttpRequest) {
          // code for IE7+, Firefox, Chrome, Opera, Safari
          xmlhttp=new XMLHttpRequest();
         }
        else {
          // code for IE6, IE5
          xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
      }
\end{verbatim}
\normalsize
Con esto hemos creado el objeto XMLHttpRequest mencionado anteriormente.
\small
\begin{verbatim}
      xmlhttp.onreadystatechange=function() {
        if (xmlhttp.readyState==4 && xmlhttp.status==200){
          document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
        }
\end{verbatim}
\normalsize
Se recoge la respuesta
\small
\begin{verbatim}
      }
      xmlhttp.open("GET","ajax_info.txt",true);
      xmlhttp.send();
\end{verbatim}
\normalsize
Enviamos la petición al servidor
\small
\begin{verbatim}
      }
    </script>
  </head>
  <body>
    <div id="myDiv"><h2>Let AJAX change this text</h2></div>
    <button type="button" onclick="loadXMLDoc()">Change Content</button>
\end{verbatim}
\normalsize
Al pulsar el botón se ejecuta la función 'loadXMLDoc()'
\small
\begin{verbatim}
  </body>
</html>
\end{verbatim}
\newpage
\subsubsection{Objeto XMLHttpRequest}
\begin{defn}[Objeto XMLHttpRequest]
(XHR), también referida como XMLHTTP (Extensible Markup Language / Hypertext Transfer Protocol), es una interfaz empleada para realizar peticiones HTTP y HTTPS a servidores Web. Para los datos transferidos se usa cualquier codificación basada en texto, incluyendo: texto plano, XML, JSON, HTML y codificaciones particulares específicas. La interfaz se implementa como una clase de la que una aplicación cliente puede generar tantas instancias como necesite para manejar el diálogo con el servidor.
\end{defn}
Es soportado por todos los navegadores modernos salvo IE5 e IE6 que emplean ActiveXObjetc. Esto cause que necesitemos poner un if en el ejemplo anterior con el fin de funcionar sobre cualquier navegador.

Se emplea para intercambiar datos con el servidor detrás de la escena, mientras la página web sigue funcionando normalmente. Esto es lo que permite actualizar parcialmente una página web.

En el ejemplo se observan dos métodos empleados sobre el objeto (además del creador):
\begin{itemize}
\item \textbf{xmlhttp.open}
Especifica el tipo de petición (GET o POST), la URL y si la petición debe atenderse de forma asíncrona o no.
\item \textbf{xmlhttp.send}
Envía la petición al servidor. Sólo recibe argumentos en caso de que la petición sea de tipo POST
\end{itemize}

Tras realizar la petición es necesario \textbf{recoger la respuesta}. La forma de hacerlo varía según la forma en que se intercambie la información.

Si es asíncrono se emplea la función: 'xmlhttp.onreadystatechange=function()', que implica que en cuanto se reciva la información solicitada se invoque a la función indicada.

Si es síncrono se coloca el código justo después del 'send', que quedará esperando la respuesta.

Si la codificación está basada en XML nos apoyamos en la propiedad 'responseXML', que contiene el contenido de la respuesta del servidor en formato XML.

Sin embargo, si la codificación es por medio de texto plano, nos debemos apoyar en la propiedad 'responseText' que contiene la respuesta del servidor en forma de cadena de texto.

\subsection{JQuery}
Es una biblioteca de JavaScript, creada inicialmente por John Resig, que permite simplificar la manera de interactuar con los documentos HTML, sobre todo facilita  el trabajo en el cliente con el DOM de una manera legible y más fácil. Además facilita los siguientes aspectos:
\begin{itemize}
\item Acceso a la estructura del documento (esto es lo que mencionábamos respecto a la facilidad de trabajar con el árbol DOM).
\item Referencias a los estilos CSS pues en jQuery también encontramos lo que en CSS denominábamos \emph{selectores}, esto es, cadenas que permiten definir qué es lo que queremos buscar en el DOM, o en otras palabras, qué query queremos aplicar sobre el DOM.
\item El trabajo sobre conjuntos de elementos
\item El tratamiento de eventos
\item La comunicación con el servidor.
\item La integración de AJAX en páginas web.
\end{itemize}


Ejemplo de jQuery:

\begin{verbatim}
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>jQuery demo</title>
</head>
<body>
<a href="http://jquery.com/">jQuery</a>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
<script>
\$(document).ready(function()\{
\$("a").click(function(event)\{
alert("As you can see, the link no longer took you to jquery.com");
event.preventDefault();
\});
\});
</script>
</body>
</html>
\end{verbatim}

Efectos en AJAX:
\begin{verbatim}
\$("a").click(function(event)\{
event.preventDefault();
\$(this).hide("slow");
\});


<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>jQuery demo</title>
</head>
<body>
<a href="http://jquery.com/">jQuery</a>
<script 
src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js"></script>
<script>
\$(document).ready(function()\{
\$("a").click(function(event)\{
event.preventDefault();
\$(this).hide("slow");
\});
\});
</script>
</body>
</html>


\end{verbatim}
Comparándolo con Javascript...
\begin{verbatim}
\$(document).ready(function() \{
\$("a").click(function() \{
alert("Hello world!");
\});
\});
\end{verbatim}
Y en el elemento HTML correspondiente:
\begin{verbatim}
<a href="" onclick="alert('Hello world')">Link</a>
\end{verbatim}

\subsection{LocalStorage y SesionStorage}
Dentro de las múltiples novedades que existen en HTML5, una de ellas es el \textbf{localStorage}. Como su propio nombre indica, se trata de un espacio de almacenamiento local. A muchos les vendrá a la mente las cookies… eso que está tan de moda últimamente en los sitios web por culpa de la conocida como “ley de cookies” (se merece un artículo sólo para ella ;)).

Pues bien, cierto es que con las cookies ya podemos almacenar información en el equipo que accede a la página web… que es exactamente de lo que se trata el \textbf{localStorage}, pero con una serie de salvedades muy importantes.

\subsubsection{localStorage vs Cookies}
La mejor forma de entender por qué es necesario el \textbf{localStorage} es indicando los tres grandes problemas de las cookies:
\begin{enumerate}
\item Espacio limitado: Una cookie sólo puede ocupar 4kb de espacio. Es por eso que las cookies suelen utilizarse sólo para almacenar un hash o un identificador que será utilizado por el servidor para identificar la visita.
\item Cada vez que se realiza una petición al servidor, toda la información que está almacenada en las cookies es enviada y también es recibida nuevamente con la respuesta del servidor. O sea, en los intercambios de información entre el navegador web y el servidor siempre van pegadas las cookies.
\item Las cookies tienen una caducidad.
\end{enumerate}

Y aquí viene \textbf{localStorage} a solucionarlos la vida!

\begin{enumerate}
\item Espacio menos limitado: \textbf{localStorage} puede ocupar entre 5 y 10MB dependiendo del navegador web. Con 5 o 10 megas ya podemos tener algo más de información ;)
\item La información almacenada con \textbf{localStorage} no es enviada al servidor en cada petición.
\item No existe una caducidad para \textbf{localStorage}, la información quedará almacenada hasta que se elimine expresamente. Aunque se cierre el navegador.
\end{enumerate}

Lo sé, una cookie tiene caducidad, pero le puedes poner que caduque dentro de 5 años… vale, sí… pero caduca, con \textbf{localStorage} nos olvidamos de tener que guardar la cookie aumentando el tiempo de caducidad.

Sin embargo, que la información persista en el tiempo, no siempre es una buena idea. A veces lo que interesa es que la información se elimina una vez se cierre el navegador. Para estos casos, en vez de utilizar \textbf{localStorage}, se debe usar \textbf{sessionStorage}.

El \textbf{sessionStorage} es exactamente igual que \textbf{localStorage}, pero con la salvedad de que una vez cerrado el navegador se pierde la información, todo lo demás es lo mismo.

\section{El lenguaje HTML5}
A coontinuación vamos a reusmir brevemente las características que presenta la versión 5 de un lenguaje que ya conocemos:

\subsubsection{Introducción}
 HTML es la unión de HTML, CSS y Jvascript para dar lugar al nuevo estándar para HTML, XHTML y HTML DOM.
No se trata de un nuevo lenguaje sino que cualquier nueva característica se basa en HTML, CSS, DOM y Javascript.

Busca cubrir los siguientes objetivos:
\begin{enumerate}
\item Reducir la necesidad de pluggins externos, como por ejemplo Flash.
\item Mejorar el manejo de errores
\item Reducir la cantidad \emph{scripting} aumentando el número de etiquetas.
\item Ser independiente del dispositivo en el que se visualice la página web.
\item Hacer el proceso de desarrollo de este nuevo estándar totalmente público.
\end{enumerate}

\subsubsection{Características}

\begin{enumerate}
\item Se identifica por la primera línea del fichero HTML:
\begin{verbatim}
<!DOCTYPE html> 
\end{verbatim}
\item Incorpora nuevos elementos que dan mayor especificidad a la estructura del documento:
\begin{verbatim}
header, nav, article, section, aside, footer...
\end{verbatim}
\item Incorpora nuevos tags para integrar vídeo y audio:
\begin{verbatim}
<video width="320" height="240" controls="controls"> 
 <source src="movie.mp4" type="video/mp4" /> 
 <source src="movie.ogg" type="video/ogg" /> 
Your browser does not support the video tag. 
</video> .
\end{verbatim}
\item Incorpora tecnología \emph{canvas}, esto es, una API Javascript, para dibujar:

\begin{verbatim}
<!DOCTYPE html> 
<html> 
<body> 
<canvas id="myCanvas" width="200" height="100" style="border:1px solid #c3c3c3;"> 
Your browser does not support the canvas element. 
</canvas> 
<script type="text/javascript"> 
var c=document.getElementById("myCanvas"); 
var cxt=c.getContext("2d"); 
cxt.moveTo(10,10); 
cxt.lineTo(150,50); 
cxt.lineTo(10,50); 
cxt.stroke(); 
</script> 
</body> 
</html> 
\end{verbatim}
\item Incorpora un mejor soporte para el alamcenamiento local offline.
\item Ningún navegador lo soporta completamente todavía, pues no es recomendación W3C de momento y está en desarrollo.
\end{enumerate}
\subsubsection{Nuevos elementos}

\begin{enumerate}
\item\textbf{Nuevos elementos de estructura}

Con la versión anterior de HTML (HTML4) sólo existía un tipo de caja (<div>), por lo que una caja podía contener cualquier tipo de contenido. 

Con HTML5, entender y encontrar cualquier elemento o contenido es mucho más rápido, sencillo y fiable, de modo que, al ver nosotros, cualquier persona (o "araña/robot" que explore nuestra página) una estructura html es posible identificar la organización del contenido con un primer golpe de vista. 

Las nuevas etiquetas son las siguientes:

\textbf{<header>}:
Es el equivalente a la cabecera de la página web. Contiene el título o nombre de la empresa/titular de la página, logo e información relacionada.

\textbf{<nav>}:
Contiene los enlaces (barra de navegación) externos o internos de la página.

\textbf{<section>}:
Es una gran caja que sirve para mostrar grandes bloques de contenido de la página. Puede contener diferentes subapartados de diferentes temas (de tipo <article>).

\textbf{<article>}:
Es una caja independiente de contenido que puede estar contenida (o no) dentro de un <section>. Normalmente utilizada para contenidos no demasiado extensos.

\textbf{<aside>}:
Define un bloque de contenido relacionado de manera indirecta con el contenido principal, pero que no es esencial para la compresión del mismo.

\textbf{<footer>}:
Equivale al pie de página de un apartado concreto (<section>, <article>...) o de la página web en general.



\item \textbf {Nuevas etiquetas de carácter general}

\textbf{<bdi>} - significa aislamiento bi-direccional. La etiqueta <bdi> aísla una parte del texto para que pueda ser formateada en una dirección distinta de otro texto fuera de ella. Actualmente no está disponible con todos los navegadores más importantes.

\textbf{<command>} - define un comando (un botón de radio, una casilla de verificación o un botón de comando) que el usuario puede invocar. Actualmente solo está soportado por Internet Explorer.

\textbf{<details>} - especifica otros detalles, que el usuario puede mostrar u ocultar. Actualmente sólo es compatible con Chrome.

\textbf{<summary>} - define un título visible para el elemento <details>. El título se puede hacer clic para ver / ocultar los detalles. Actualmente sólo es compatible con Chrome.

\textbf{<figure>} - define los elementos gráficos contenidos en el documento. Para más información y ejemplos en la etiqueta <figure>, visita 
http://appdeveloper.intel.com/en-us/blog/2011/11/05/html5-section-tags

\textbf{<hgroup>} - el título de una sección. El elemento se utiliza para agrupar un conjunto de elementos h1-h6, cuando el título tiene varios niveles, tales como subtítulos, títulos alternativos, o frases.

\textbf{<mark>} - piezas que destacan el texto.

\textbf{<meter>} - define una medida escalar dentro de un rango conocido, o un valor fraccionario.

\textbf{<progress>} - representa el progreso de una tarea. Actualmente compatible con Firefox, Opera y Chrome.

\textbf{<ruby>} - indica las anotaciones de Ruby, que se utiliza para la tipografía de Asia oriental, para mostrar la pronunciación de los caracteres de Asia oriental. 

\textbf{<rt>} - define una explicación o una pronunciación de caracteres (para la tipografía del este asiático) en una anotación de rubí.

\textbf{<rp>} - define lo que demuestra si un navegador es o no compatible con las anotaciones de rubí.

\textbf{<section>} - una sección genérica dentro del documento, con su propia estructura. Para más información y ejemplos en la etiqueta <section>, visita http://appdeveloper.intel.com/en-us/blog/2011/11/05/html5-section-tags

\textbf{<time>} - define un tiempo (24 horas), o una fecha, opcionalmente, con un tiempo de desplazamiento y una zona horaria. En la actualidad no es compatible con ninguno de los navegadores más importantes.

\textbf{<wbr>} - especifica el lugar en un texto en el que estaría mal agregar un salto de línea. Si una palabra es muy larga, esto indica que una separación de palabras sería posible en el navegador.

\item \textbf {Nuevos elementos multimedia}

\textbf {<audio>} - define un flujo de sonido, la música o el audio.

\textbf {<video>} - define un recurso de vídeo.

\textbf {<source>} - se utiliza para especificar los recursos de medios múltiples para los elementos de audiovisuales, como <video> y <audio>. También permite especificar video alternativo / archivos de audio que el navegador puede elegir, en función de su tipo de medio o soporte de códec.

\textbf {<embed>} - define un área donde se incluye aplicaciones externas o contenido interactivo

\textbf {<track>} - especifica pistas de texto para los elementos audiovisuales. En la actualidad no es compatible con ninguno de los navegadores más importantes.

 \item \textbf{Nuevos elementos de formulario}

 \textbf{<datalist>} - especifica una lista de opciones predefinidas para los controles de entrada. Se usa junto a <input>. Actualmente sólo es compatible con Firefox y Opera.

Ejemplo:
\begin{verbatim}
<!DOCTYPE html> 
…. 
<form action="demo_form.asp" method="get"> 
<input list="browsers" name="browser"> 
<datalist id="browsers"> 
 <option value="Internet Explorer"> 
 <option value="Firefox"> 
 <option value="Chrome"> 
 <option value="Opera"> 
 <option value="Safari"> 
</datalist> 
<input type="submit"> 
</form> 
<p><b>Note:</b> The datalist tag is not supported in Internet Explorer 9 and earlier 
versions, or in Safari.</p> 

\end{verbatim}

\textbf{<keygen>} - especifica un campo generador para claves con un formulario. Permite generar un par clave pública/clave privada. Cuando se envía el formulario, la clave privada se almacena localmente, y la clave pública se envía al servidor. La idea es que se utilice para generar un certificado que permita establecer comunicación segura  entra cliente y servidor.

Ejemplo:

\begin{verbatim}
<keygen name="name"	challenge="challenge string"	keytype="type"	keyparams="pqg-params">	
\end{verbatim}
Donde \emph{keytype} idica el algoritmo de encriptación (por defecto RSA) y \emph{keyprams} depende del algoritmo y en el caso de RSA, es ingorado.

Ejemplo incorporado en un form (recuerda que este elemnto es olo valido dentro de un formulario):
\begin  {verbatim}
<form action="demo_keygen.php method="get">	
Username:	<input	type="text"	name="usr_name">	
Encryption:	<keygen name="security">	
<input	type="submit">	
</form>
\end{verbatim}	
Este elemento permite elegir tambiénel tamaño de la clave al usuario por medio de un desplegable. Cuando el usuario una vez haya introducido el \emph{username} y haya seleccionado la longitud de la clave que se le aplica al campo pincha en \emph{Submit} y el resultado es el siguiente:

\begin  {verbatim}
http:// … /demo_keygen.php? 
usr_name=alvaro\&security=MIIBNjCBojCBnTALBgkqhkiG9w0BAQE
DgY0AMIGJAoGBAMUwkJ\%2ByC
\%2BLCShRsKIbAJpAImAl8utJC9k3AFEj5d6uJTjgP8C3YRoOU1xkR
Q22ywO4FYoQ\%2FzlcZb07OZs0fa3M50qY
\%2FldLXNaNBTB4jbqJPsFI9giyuuKIGqWiMn
\%2FtLW6dIWeqkTn5uBLnNk3LXpl99rvPS2FRBGyoKvY8Q6GS9Ag
MBAAEWADALBgkqhkiG9w0BAQQDgYEAMT7D6QCrF5GOsxQCt1
ZjJfsmW2ZdKvb7zoiXUcC1dMZ4po9STphlGHDe4IVbXa6k3bgxjWcb
ONrHg2RU5veuet71wAcLEtecJTMkGOgMlSDf0VJhtpjrrAhN4FSDT7
y5c2AQKni3D9ZzjI0fV4kIg8rTt4pG\%2F\%2BZ2JK5K5XFdoOI\%3D 
\end{verbatim}

\textbf{<output>} - representa el resultado de un cálculo, al igual que el realizado por una función. Esta pensada para ser escrita desde Javascript. Incorpora al HTML el reusltado de una cierta operación cuando está lista,  dinámicamente.

Ejemplo:
\begin{verbatim}
<form action="demo_form.asp"	method="get"	
oninput="x.value=parseInt(a.value)+parseInt(b.value)">	
0	
<input	type="range"	id="a"	name="a"	value="50">	
100	+	
<input	type="number"	id="b"	name="b"	value="50">	
=	
<output	name="x"	for="a	b"></output>	
<input	type="submit">	
</form>	
\end{verbatim}


\item \textbf{Nuevos controles para las entradas \emph{ (input)} de  formulario}

\textbf {search:} <input type=”search”> Para cajas de búsqueda. 

\textbf {number:} <input type=”number”> Para sumar o restar números mediante botones. 

\textbf {range:} <input type=”range”> Para seleccionar un valor entre dos valores 
predeterminados. 

\textbf {color:} <input type=”color”> Seleccionar un color. 

\textbf {tel:} <input type=”tel”> Números telefónicos. 

\textbf {url:} <input type=”url”> Direcciones web. 

\textbf {email:} <input type=”email”> Direcciones de email. Lo nuevo es que se auto valida. 

\textbf {date:} <input type=”date”> Para seleccionar un día en un calendario. 

\textbf {month:} <input type=”month”> Para meses. 

\textbf {week:} <input type=”week”> Para semanas. 

\textbf {time:} <input type=”time”> Para fechas. 

\textbf {datetime:} <input type=”datetime”> Para una fecha exacta, absoluta y tiempo. 

\textbf {datetime-local:} <input type=”datetime-local”> Para fechas locales y frecuencia.

Ejemplo de entrada de tipo \textbf{number}:

\begin{verbatim}
<form action="demo_form.php">	
		Quantity:	
		<input	type="number"	name="points"	
			min="0"	max="100"	step="10"	value="30">	
		<input	type="submit"	value="Send">	
</form>
\end{verbatim}

Ejemplo de entrada de tipo \textbf{date-time local}
\begin{verbatim}
Depending on	browser	support:<br>	
A	date	picker	can	pop-up	when you enter the	input	field.	
</p>	
<form action="demo_form.php">	
		Birthday	(date	and	time):	
		<input	type="datetime-local"	name="bdaytime">	
		<input	type="submit"	value="Send">	
</form>	
<p><b>Note:</b>	
type="datetime-local"	is not supported	in	Firefox	and	
Internet	Explorer.	
</p>	
\end{verbatim}

\item \textbf{Almacenamiento de la información: localStorage}

Reemplaza las cookies almacenando pares clave/valor permitiendo más espacio (hasta 5MB) y no se envían al servidor en cada comunciación http.

Ejemplo de \textbf{lectura}:
\begin{verbatim}
var	foo	=	localStorage.getItem("bar");	
//	retorna	null	si	la	clave	no	existe
//	alternativa sintáctica
var	foo	=	localStorage["bar"];	
\end{verbatim}


Ejemplo de \textbf{escritura}:
\begin{verbatim}
localStorage.setItem("bar",	foo);	
//	modifica	el	valor	si	la	clave	existe
//	alternativa sintáctica
localStorage["bar"]	=	foo;		
\end{verbatim}


Ejemplo de uso de \textbf{localStorage}:
\begin{verbatim}
<script>	
//	Check	browser	support
if	(typeof(Storage)	!=	"undefined")	{	
				//	Store
				localStorage.setItem("lastname",	"Smith");	
				//	Retrieve
				document.getElementById("result").innerHTML	=	
localStorage.getItem("lastname");	
}	else	{	
				document.getElementById("result").innerHTML	=		
"Sorry,	your	browser	does not support	Web	Storage...";	
}	
</script>
\end{verbatim}
	
\item \textbf{Almacenamiento de la información: sessionStorage}

Similar a localStorage pero la informacion en este caso desaparece con el cierre del navegador (o la pestaña).

Ejemplo de \textbf{ sessionStorage}
\begin{verbatim}
<script>	
function clickCounter()	{	
				if(typeof(Storage)	!==	"undefined")	{	
								if	(sessionStorage["clickcount"])	{	
												sessionStorage["clickcount"]	=	Number(sessionStorage["clickcount"])+1;	
								}	else	{	
												sessionStorage["clickcount"]	=	1;	
								}	
								document.getElementById("result").innerHTML	=	"You have clicked the button	"	+	
	 	sessionStorage["clickcount"]	+	"	time(s)	in	this session.";	
				}	else	{	
								document.getElementById("result").innerHTML	=		
	 	"Sorry,	your	browser	does not support	web	storage...";	
				}	
}	
</script>
\end{verbatim}	
\end{enumerate}

\section{Componentes Java en el servidor}
\subsubsection{Breve entrada en contexto: }
Java 2 es el lenguaje Java vigente. Recordemos que se trata de uno de los lenguajes más utilizados hoy en día y la razón es que provee una amplia integración con cualquier tipo de sistema. Es posible ejecutar un programa Java en distintas palataformas, dispositivos o tipos de ordenadores, siendo compatible con cualquier O.S. Todo esto es gracias a la Máquina Virtual de Java que se encarga de traducir las instrucciones del lenguaje Java, de forma personalizada a cualquier dispositivo de usuario. 

Existen 3 distribuciones principales de Java 2, con aspectos comunes y peculariedades propias. Éstas son:
\begin{itemize}
\item J2SE
Sus siglas significan Java 2 Standard Edition.
Esta distribución está orientada al desarrollo de aplicaciones cliente/servidor. No presenta soporte para tecnologías en Internet, sino que fundamentalmente se usa para desarrollar aplicaciones de escritorio. Es la más utilizada.
\item J2EE 
Java 2 Enterprise Edition. Está orientada a empresas y a la integración entre sistemas. Incluye soporte a tecnologías para Internet y por tanto, su uso fundamental es el desarrollo de aplicaciones ejecutadas en Internet. Está  basado en J2SE.
\item J2ME 
Java 2 Micro Edition. Está orientado a pequeños dispositivos móviles (teléfonos, tabletas,...)
\end{itemize}

\subsubsection{Nuestro objetivo: J2EE}
J2EE añade a Java la funcionalidad necesaria para convertirse en un lenguaje orientado al desarrollo de servicios en Internet mediante 3 elementos fundamentales : \textbf {JSP} (un lenguaje de programación de páginas web dinámicas como PHP o ASP) y \textbf{Servlets} (scripts o programas CGI en el servidor como los de Perl) y \textbf{Enterprise Java Beans o EJB}.
Estos 3 componentes simplifican la programación de servidores en el modelo Web-Java al definir una interfaz con los elementos de comunicación establecidos en el protocolo HTTP y formularios HTML y nos mantendrán ocupados durante esta unidad
\subsection{Enterprise Java Beans a.k.a EJB}
\subsubsection{Java Beans. El concepto general:}

Un Java Bean o bean es un componente hecho en software que se puede reutilizar y que puede ser manipulado visualmente por una herramienta de programación en lenguaje Java.
Para ello, se define un interfaz para el momento del diseño que permite a la herramienta de programación o IDE, interrogar (\emph{query}) al componente y conocer las propiedades (\emph{properties}) que define y los tipos de sucesos (\emph{events}) que puede generar en respuesta a diversas acciones.

La idea de Java Beans surge de una vieja necesidad de la Ingeniería del Software: contar con componentes reutilizables e independientes de la plataforma. El programador que hace el JB no hace nada misterioso, simplemente define una clase, tratando de encapsular (ocultar su implementación) y mostrando al exterior (el programador que usa el bean) solamente los métodos y propiedades que son públicos. Sólo se muestra aquello que forma parte del servicio que el bean ofrece al exterior.

La idea que se busca es liberar al programador del problema de la persistencia (mantener en el tiempo el estado de los beans que pueden ser personalizados por el propio programador), la integridad de las transacciones (problemas de concurrencia en el acceso a  objetos compartidos) y seguridad entre otros, para que este puede dedicarse en profundidad al problema en cuestión.


\subsubsection{EJB. Un caso particular:}
Las Enterprise Java Beans siguen una línea conceptual de los JavaBeans. En este caso se trata de un componente \emph{server-side} que encapsula la lógica del negocio de una cierta aplicación.

 Por último, cabe mencionar que, en el caso del Proyecto de S.I, usamos las llamadas JPA Entities (Entitity Beans de la Java Persistence API) como  una representación en lenguaje Java de nuestras entidades en una BD. Permiten interaccionar de manera segura con  la BD mediante invocación de métodos  que básicamente se encargan de ejecutar \emph{queries} sobre la BD y tratar su resultado. El puente que permite la conexión de objetos Java con entidades de una base de datos es lo que conocemos como JDBC, que no es más que una tecnología de acceso a datos basada en Java que provee de una serie de métodos para ejecutar \emph{queries} y actualizar datos en una BD. 
 
\newpage
\subsection{Servlets}
\begin{defn}[Servlet]
Es una clase en el lenguaje de programación Java, utilizada para ampliar las capacidades de un servidor.
\end{defn}

Aunque los servlets pueden responder a cualquier tipo de solicitudes, éstos son utilizados comúnmente para extender las aplicaciones alojadas por servidores web, de tal manera que pueden ser vistos como applets de Java que se ejecutan en servidores en vez de navegadores web. Este tipo de servlets son la contraparte Java de otras tecnologías de contenido dinámico Web, como PHP y ASP.NET.

En el fondo son similares a los CGI aunque con una sintaxis más sencilla. Además, necesitan un servidor específico, por ejemplo Tomcat.

\begin{defn}[Tomcat]
Apache Tomcat (también llamado Jakarta Tomcat o simplemente Tomcat) funciona como un contenedor de servlets desarrollado bajo el proyecto Jakarta en la Apache Software Foundation. Tomcat implementa las especificaciones de los servlets y de JavaServer Pages (JSP) de Oracle Corporation (aunque creado por Sun Microsystems).
\end{defn}

Los servlets se ejecutan en el servidor y se accede a ellos mediante un URL (esta depende del servidor de servlets que utilicemos).

\subsubsection{Portabilidad, felxibilidad y seguridad}
La interconexión del servlet se basa en una API definida en el estándar de Java, independiente de la plataforma. Esto le proporciona gran portabilidad pues el código java es altamente transportable. Además permite aprovechar objetos reutilizables ( los \textbf{Java Beans}).

En cuanto a seguridad, los servlets se ejecutan bajo un único proceso (\textbf{servlet engine}), lo que permite acceso protegido y su integración en un entorno de autentificación única (\textbf{single sign on}).

\subsubsection{Ventajas de rendimiento}
Comparten las ventajas de las interfaces híbridas pues tienen un entorno de ejecución propio, se ejecutan y permanecen en memoria, mantienen sesiones entre peticiones HTTP, son multitarea, escalables entre multiprocesadores y sistemas heterogéneos, etc.

\subsubsection{Invocación básica de un Servlet}
\begin{enumerate}
\item El cliente realiza una petición al servidor web, especificando el nombre del servlet como parte de la URL
[\textbf{Potocolo de comunicación} : HTTP]
\item El servidor web pasa la petición a la servlet engine o servlet container, que localiza una instancia de la clase servlet y crea una nueva tarea.\newline
[\textbf{Potocolo de comunicación} : IPC genericos (mecanismo de comunciación entre procesos) como HTTP y IIOP (protocolo de ocmunicacion entre objetos)]
\item La servlet engine ejecuta el método service del servlet
\item La interacción del servlet con el sistema se realiza a través de servicios estándar de la servlet engine, que actúa como contenedor de los objetos y garantiza la independencia de la plataforma.
\end{enumerate}

\subsubsection{Ciclo de vida de los servlets}
\begin{itemize}
\item El método 'init' se ejecuta por la \textbf{servlet engine} al cargarlo
\item El método 'service' se ejecuta en cada petición de los clientes
\item El método 'destroy' se ejecuta por la \textbf{servlet engine} al descargarlo
\end{itemize}

\subsubsection{Http Servlet}
Se trata de un servlet específico para llamadas HTTP.

Define dos nuevos métodos: 'doGet' y 'doPost' que atienden a las peticiones HTTP GET y HTTP POST respectivamente. Ambos métodos se ejecutan desde el método 'service'. Las subclases de Http Servlet deben redefinir estos métodos para ejecutar las acciones pertinentes. También pueden redefinir la métodos init() y destroy().

\subsubsection{Crear un servlet}
Para crear un servlet debemos definir una subclase de javax.servlet.http.HttpServlet, implementar alguno de los métodos: 'doGet', 'doPost' o 'service' y dar de alta el servlet en el servidor de servlets.

\subsubsection{Ejecutar un servlet}
\begin{enumerate}
\item El cliente se conecta al servlet como URL
\begin{itemize}
\item Directamente tecleado en el navegador
\item En un enlace HTML ó desde un formulario HTML
\item En un objeto URL de java
\end{itemize}
\item El servlet se carga (en el servidor)
\begin{itemize}
\item Se carga la clase del servlet
\item Se crea una instancia
\end{itemize}
\item El servlet se arranca (en el servidor)
\begin{itemize}
\item Se ejecuta uno de sus métodos
\end{itemize}
\item El servlet termina
\item El cliente lee la salida del servlet, típicamente un string con código HTML para una página web
\end{enumerate}

\subsubsection{Comunicación entre cliente y servlet}
Se realiza por medio de \emph{stream}s de entrada y salida.

La salida del servlet se emplea para generar páginas web que son enviadas al cliente. La salida del cliente hacia el servlet es menos frecuente; para enviar datos al servlet normalmente se utilizan parámetros.

\textbf{Parámetros HTTP:}

Se envían como parte del URL o con un formulario HTML.

\textbf{Peticiones del cliente y respuestas del servidor}

Los métodos service (), doGet() y doPost() tienen 2 parámetros:

\begin{enumerate}
\item HttpServletRequest:
Recibe los parámetros de entrada de la petición del cliente. Éstos son:
Content-type, length, method, URL, path...

\item HttpServletResponse:
Proporciona servicios que permiten enviar la respuesta al cliente desde el servidor. Éstos son:

set Content-type, redirect.
\end{enumerate}

\subsubsection{HttpServletRequest}
Se trata de una clase java que representa la petición del cliente. Sus métodos principales son:
\begin{itemize}
\item getParameterNames(): Devuelve una enumeración con los
parámetros recibidos desde la página HTML.
\item getParameterValues(String name): Devuelve los valores de un parámetro multivalorado.
\item getParameter(String name): Devuelve el valor de un
parámetro simple.
\item getReader(): Devuelve un objeto de la clase BufferedReader para leer el cuerpo de la petición HTTP.
\end{itemize}

Ver ejemplo en la diapositiva 8B de la parte 5.
\subsubsection{HttpServletResponse}
Se trata de una clase java que proporciona el canal de comunicación de retorno con el cliente. Sus métodos principales son:
\begin{itemize}
\item setContentType(String type): Selecciona el tipo MIME de
la respuesta que se devuelve al cliente.
\item sendError(int sc): Devuelve el código de error sc al cliente.
\item sendRedirect(String URL): Redirige el navegador a la URL que se especifica como parámetro.
\item getWriter(): Devuelve un objeto de la clase PrintWriter
para realizar la salida de la página a enviar al cliente, mediante escritura en modo texto.
\item getOutputStream(): Devuelve un objeto de la clase
ServletOutputStream que permite devolver al cliente un
contenido binario.
\end{itemize}

Ver ejemplo en la diapositiva 9B de la parte 5.

\textbf{Nota:} Se recomienda leer los ejemplos de Servlet, envío  y lectura de parámetros entre cliente y servidor de las diapositivas 10-12.


\subsubsection{Gestión de la sesión}
Los servlets gestionan el estado de la conexión de un usuario al servidor  a través del objeto HttpSession.

Este objeto representa una conexión cliente-servidor cuya vida se alarga a través de múltiples invocaciones del cliente, incluso a distintos servlets. Se identifican a través de la consulta mediante un identificador de sesión.

El servlet accede a este objeto mediante el método 'getSession (boolean create)' de la clase HttpServletRequest, donde si el parametro create es true y la sesión noexiste se crea una nueva.

Estas sesiones almacenan información específica de la aplicación como parejas clave-objeto a través de los métodos: 'setAttribute (String clave, Object valor)' y 'getAttribute (String clave)'.

Los objetos que se almacenan deben ser serializables y es la \textbf{servlet engine} quien se encarga de establecer el método de identificarlos.
\textbf{Nota:} Se recomienda leer el ejemplo de uso de sesión de  la diapositiva 13B.
\subsubsection{¿Se debe sincronizar?}
Las especificaciones de Java dicen que no hace falta, puesto que no hay acceso concurrente cuando dos usuarios diferentes acceden a la misma página simultáneamente. Pero con Ajax, es posible que dos llamadas asíncronas del mismo usuario lleguen (casi) simultáneamente.

Por ello debemos tomar precauciones y no sincronizar sobre la instancia del servlet sino sobre la sesión.
Se recomienda hacer lo siguiente:\newline
 \newline
 HttpSession session = request.getSession();\newline
\t synchronized(session)\newline \{\newline
SomeClass value =(SomeClass)session.getAttribute("someID");\newline
if (value == null) \{\newline
value = new SomeClass(...);\newline
\}\newline
doSomethingWith(value);\newline
session.setAttribute("someID", value);
\}\newline
 \newline
\textbf{Nota:} Se recomienda leer el ejemplo de tratamiento de sesiones de  la diapositiva 15A.
\subsubsection{Servlet Context}
Dento de una \textbf{servlet engine} se almacena información asociada al servidor y a los servlets o a determinados grupos de servlets que se ejecutan.

Estos acceden a ella traves de la clase ServletContext que contiene parámetros para la inicialización así como atributos.

El servlet puede almacenar y recuperar atributos a través de los métodos 'setAttribute' y 'getAttribute'.

\subsubsection{Request Dispatcher}
Se trata de una interfaz que permite a un servlet realizar consultas HTTP redirigiendo la consulta a una nueva URL (forwarding) o ejecutando la consulta y recuperando el control de nuevo tras su ejecución.

Se adquiere a través del contexto mediante el método 'getRequestDispatcher' y tiene dos métodos básicos para realizar los dos tipos de llamadas descritos que reciben como parámetros los mismos objetos que el servlet origen: 'forward' e 'inlcude'.

Ambos métodos permiten ir de un servlet/jsp a otra página web al final del procesamiento, pero son ligeramente distintos:
\begin{itemize}
\item \textbf{Forward}
Se ejecuta internamente sin que el navegador perciba el cambio. Por tanto la URL no cambia y cualquier recarga del navegador cargará la página original.
\item \textbf{Redirect}
Se trata de un proceso en dos pasos donde la aplicación web le indica al navegador que debe acceder a una segunda URL, distinta de la de origen. Una recarga nos mandaría a esa segunda URL.

Es algo más lento que el 'forward' y los objetos disponibles en el request original no lo están en el segundo.
\end{itemize}

Se debe usar forward sólo si la operación del servlet puede ser repetida sin problemas, sino debe usarse redirect. En el contexto de una base de datos:
\begin{itemize}
\item Usar forward para operaciones SELECT de la base de datos.
– Y normalmente método GET de envío de datos
\item Usar redirect para operaciones INSERT, DELETE, UPDATE.
– Y normalmente método POST de envío de datos.
\end{itemize}

\subsubsection{Ejecución detallada de una petición a un servlet}
\begin{enumerate}
\item El cliente lo solicita mediante una URL con su nombre y clase
\begin{itemize}
\item http://miservidor/servlets/com.ibm.aplicacion.Servlet1
\item Algunos servidores admiten asignación de nombres a cada servlet para independizarlos del nombre de la clase.
\end{itemize}
\item El servidor detecta que se trata de un servlet y lo pasa a la servlet engine.
\item La servlet engine pasa esta información a un servlet especial, denominado invoker.
\item invoker comprueba si el servlet está cargado en memoria
\begin{itemize}
\item Si lo está, crea una nueva tarea (hilo) sobre la misma instancia.
\item Si no lo está, busca el objeto en el CLASSPATH, crea una nueva instancia, ejecuta su método init y ejecuta la petición.
\end{itemize}
\end{enumerate}

\subsection{JavaServer Pages (JSP)}
\begin{defn}[JSP]
Es una tecnología que ayuda a los desarrolladores de software a crear páginas web dinámicas basadas en HTML, XML, entre otros tipos de documentos. JSP es similar a PHP, pero usa el lenguaje de programación Java.
\end{defn}

Permite mezclar código HTMl y código Java, necesita un servidor web que lo soporte y se accede igual que a una página html desde un navegador. Se ejecutan en una \textbf{servlet engine (jsp engine)}

Las JSP son convertidas en un servlet dinámicamente la primera vez que se ejecutan y se crea un objeto que implemente la interfaz HttpJspPage.

Un archivo JSP contiene código HTML nativo, elementos de JSP (directivas o acciones estándar, elementos del lenguaje, etc).

\subsubsection{Objetos implícitos}
Hay una serie de objetos que siempre se encuentra definidos en una JSP sin necesidad de que los defina el usuarios. Los principales son:
\begin{itemize}
\item page: Representa la página jsp que se está ejecutando.
\item request: Consulta recibida del usuario (tipo HttpServletRequest).
\item response: Objeto para generación de resultado (tipo HttpServletResponse).
\item session: Sesión de trabajo del cliente (tipo HttpSession)
\item application: Contexto de los servlets (tipo ServletContext)
\item out: Permite la escritura en la página de salida (tipo JspWriter)
\item exception: En páginas de error, contiene la condición de error por la que se han ejecutado.
\end{itemize}

\subsubsection{Directivas y acciones}
\begin{itemize}
\item Directivas: Mensajes para la \textbf{jsp engine}
\begin{verbatim}
– <%@ page {atributo="valor"}* %>
Define propiedades generales de la página: lenguaje, Classpath,
herencia, imports...
– <%@ include file="nombre_archivo" %>
Orden de incluir un archivo en la página actual, en tiempo de
compilación.
– <%@ taglib uri="URI_archivo_etiquetas" %>
Referencia a un archivo con declaración de etiquetas de usuario.
\end{verbatim}
\item Aciones: Comandos a realizar en tiempo de ejecución
\begin{verbatim}
– <jsp:include page="URLrelativa" />
– <jsp:forward page="URLrelativa" />
  /*Los dos anteriores realizan una llamada al RequestDispatcher */
– <jsp:useBean id="nombre" scope="page|request|session|application"
class="nombreCompletoClase" />
Define para su uso en la página un javaBean con el nombre
"nombre".
– <jsp:setProperty name="nombre" property="propName"
value="valor"/>
Activa una propiedad del JavaBean "nombre".
– <jsp:getProperty name="nombre" property="propName" />
Recupera una propiedad del JavaBean "nombre" y la almacena en la
página.
\end{verbatim}
\end{itemize}

\subsubsection{Elementos del lenguaje}
\begin{verbatim}
Declaraciones de variables y métodos
– <%! declaracion %>
– Se pueden declarar aquí los métodos especiales
• jspInit(): Se ejecuta al iniciar la página JSP.
• jspDestroy(): Se ejecuta al destruir la página JSP.
Scriptlets: Contiene cualquier fragmento de código válido en lenguaje Java.
– <% fragmento_de_código %>
– El código introducido se copia al cuerpo del método del servlet compilado
Expresiones: Cualquier expresión Java válida
– <%= expresión %>
– En tiempo de ejecución:
• Se evalúa la expresión.
• El resultado se convierte a String.
• Se presenta en la página resultado.
\end{verbatim}

\subsubsection{Ejecución detallada de una petición de una JSP}
\begin{enumerate}
\item El cliente envía una petición.
\item El servidor detecta que la petición se resuelve mediante JSP.
\begin{itemize}
\item Pasa la petición a la servlet engine correspondiente.
\end{itemize}
\item La servlet engine comprueba si el archivo JSP está compilado.
\begin{itemize}
\item Si no lo está, lo compila mediante un servlet de compilación de páginas (PageCompileServlet, JspServlet)
\end{itemize}
\item La servlet engine pasa la petición al servlet invoker, que actúa como con cualquier otro servlet:
\begin{itemize}
\item Comprueba si está instanciado, y si no lo está, lo instancia y ejecuta su método init.
\item La servlet engine ejecuta el método correspondiente del servlet en una nueva tarea (hilo) para atender al servicio.
\end{itemize}

\end{enumerate}
\normalsize
\printindex
\end{document}
