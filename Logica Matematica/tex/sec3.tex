% -*- root: ../LogicaMatematica.tex -*-
\section{Computación}

\subsection{Motivación}

\paragraph{La ecuación diofántica:} $x^2+y^2=z^2$ tiene soluciones no triviales en enteros, por ejemplo, $x=3, y=4, z=5$. Consideramos el caso $n>2$, luego tenemos $x^n+y^n = z^n$, que tiene soluciones triviales ($x=y=z=0$). y no tiene soluciones no triviales en enteros (Wiles, 1995).

\paragraph{X problema de Hilbert:} Hallar un algoritmo tal que, dada cualquier ecuación diofántica, nos dice si tiene soluciones en enteros o no. Es decir, dado cualquier polinomio con coeficientes en $\mathbb{Z}$, dependiente de cualquier número de variables, $x_1,\hdots, x_m$, el algoritmo decide si $p(x_1, \hdots, x_m)=0$ tiene soluciones en enteros o no.

\obs Se pide un sólo algoritmo que debe funcionar para todas las ecuaciones diofánticas.


En 1970, Yuri Matiyasevich, basándose en trabajos previos de Martin Davies, Hilary Putnam y Julia Robinson, demostró que no existe tal algoritmo.


Informalmente, el teorema de incompletitud de Gödel nos dice que dada cualquier axomatización (computable) de la aritmética, la teoría resultante es incompleta. Más precisamente, tenemos:

\begin{theorem}[]
Sea $\mathcal{N} = (ℕ,0,s,+,·,<)$ el modelo estándar de los  naturales. Sea $Σ$ una teoría axiomatizable de sentencias verdaderas en $\mathcal{N}$.

\textbf{Entonces} existe una sentencia $σ$ tal que $\mathcal{N} \vDash σ$ pero $Σ\nvdash σ$, con lo que $Σ$ es incompleta.

\end{theorem}

\obs Como la teoría $Σ$ tiene un modelo, no podemos derivar contradicciones, es decir, es consistente.

\begin{proof}
Sistemáticamente obtenemos todas las consecuencias lógicas de la teoría.

Dada cualquier ecuación diofántica, $p(x_1,...,x_n) = $ si $Σ$ fuese completa, tras un número finito de pasos obtendríamos 
\[Σ\vdash ∃x_1,...,x_n p(x_1,...,x_n) = 0 \text{ ó } Σ\vdash \nexists x_1,...,x_n p(x_1,...,x_n) = 0\]

Y resolveríamos el $X$-problema de Hilbert afirmativamente.

Y como el $X$-problema de Hilbert no tiene solución, deducimos que $Σ$ no es completa.
\end{proof}

\begin{example}
Vamos a definir $f:ℚ\to ℕ^2$ de la forma: $f\left(\frac{a}{b}\right) = (a,b)$ y el siguiente paso es definir la inyección en $ℕ$:

\textcolor{red}{dibujo}

\end{example}
\begin{example}
Sea $x^3 + y^3 = z^3$

Podríamos ir intentando probar con $(x,y,z) = (1,1,1) \to (1,1,2) \to (1,1,3) \to ... \to (1,1,n)$ pero este sistema no es muy bueno. Lo que habría que hacer sería:

$(x,y,z) = (1,1,1) \to (1,1,2) \to (1,2,1) \to (1,2,2) \to (2,1,1) \to (2,1,2) \to ...$ si es un procedimiento que nos asegura pasar por todas las posibilidades y que si existe una solución la encontramos en un número $n$ finito de pasos.
\end{example}

\obs Si $Σ$ es suficientemente rica como para contener los resultados básicos sobre sumas y productos (por ejemplo si contiene los axiomas $N1 - N9$ del libro), si $p(x_1,...,x_n) = 0$ para alguna $n-tupla$ $a_1,...,a_n$ , entonces $Σ\vdash ∃x_1,...,x_n p(x_1,...,x_n ) = 0$.

En el argumento anterior (idea de la prueba del teorema), odemos tomar $σ = \nexists x_1,...,x_n p(x_1,...,x_n) = 0$ para alguna ecuación diofántica.

En este caso, $\mathcal{N}\vDash σ, \text{ pero } Σ \nvdash σ$ ($σ$ depende de $Σ$).

\subsection{Máquinas de Turing}

Es importante, antes de saber lo que son las máquinas de Turing, saber que Turing se pronucia ``tiuring''.

\begin{example}
Vamos a computar la suma $15 + 267$, sumando en columna:

\[
\begin{array}{cccc}
&&1&5\\
&2&6&7\\\hline
&&&
\end{array}
\]

\begin{enumerate}
	\item Veo un 5. Lo guardo en mi memoria y bajo.
	\item Veo un 7. Lo guardo en mi memoria y bajo.
	\item Veo un hueco. Sumo lo que tengo en mi memoria y escribo el último dígito (en este caso 2) y vacío mi memoria. Si hay más dígitos, los almaceno en mi memoria (en este caso un 1).
	\item Subo arriba del todo y me muevo a la izquierda.
	\item Veo un 1. Lo guardo en mi memoria y bajo.
	\item Veo un 6. Lo guardo en mi memoria y bajo.
	\item Veo un hueco. Sumo lo que tengo en mi memoria y escribo el último dígito (en este caso 8) y vacío mi memoria. BO hay más dígitos.
	\item Subo arriba del todo y me muevo a la izquierda.
	\item Veo un hueco. Bajo
	\item Veo un 2. Lo guardo en mi memoria y bajo.
	\item Veo un hueco. Sumo lo que tengo en mi memoria y escribo el último dígito (en este caso 2) y vacío mi memoria. BO hay más dígitos.
	\item Subo arriba del todo y me muevo a la izquierda.
	\item Veo un hueco. Bajo.
	\item Veo un hueco. Bajo.
	\item Veo un hueco. Bajo.
	\item Voy arriba del todo y he acabado.
\end{enumerate}
\end{example}

\begin{defn}[Máquinas de Turing]
Variantes (que dan lugar al mismo modelo de computación)  que cumplen:

\begin{itemize}
	\item El modelo ideal de computación sin limitaciones de tiempo ni de espacio.
	\item La condición ``bidimensional'' del papel cuadriculado no es esencial. Consideramos una cinta infinita en ambas direcciones con casillas:
	\begin{center}
	\begin{tabular}{|c|c|c|c|}
	\hline 
	&&&...\\
	\hline 
	\end{tabular}
	\end{center}
	\item En las casillas encontramos símbolos pertenecientes a un alfabeto finito $S$. (En la actualidad, ese alfabeto finito sólo tiene 2 símbolos: $0$ y $1$, ya que todos los demás se pueden traducir en esos símbolos)
	\item La máquina tiene un cabezal que lee los contenidos de la celda. Puede modificarlos o dejarlos igual.
	\item Puede desplazarse a la casilla de la izquierda o a la de la derecha.
	\item La acción de una \MT depende únicamente de el contenido de la casilla que está leyendo y de su estado interno.
\end{itemize}

\end{defn}

