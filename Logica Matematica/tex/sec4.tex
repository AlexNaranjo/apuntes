\section{Incompletitud}

Los principales enunciados básicos correspondientes a esta sección ya los hemos visto. Lo que haremos será añadir ciertas definiciones y varios resultados/teoremas importantes.

\textbf{Recordatorio de lógica proposicional}
\[\{p,q\}\vdash r \iff \vdash (p\y q) \to r\]
Para demostrar esto empezábamos apoyándonos en el teorema de la deducción:
\[\{p,q\} \vdash r \implies \{p\} \vdash q \to r\]
Aplicando de nuevo el teorema de la deducción obteníamos:
\[\{p\} \vdash q \to r \implies \vdash p \to (q \to r) \equiv (p \y q ) \to r\]

\begin{theorem}
Consideramos el lenguage de la aritmética formal, definido como:
\[L=\{0,S_i,+_1,\cdot_1, <_1\}\]
y la teoría $\underline{N}=\{N_1,...,N_9\}$ correspondiente a los axiomas de Peano (sin incluir inducción) y definida en el libro en la página 91.

en este lenguaje, $L$, y con la teoría $\underline{N}$, toda función recursiva total $\appl{f}{\nat^k}{\nat}$ es representable para una fórmula de primer orden $\varphi_f$.

Lo mismo ocurre con los conjuntos recursivos.
\end{theorem}

\begin{prop}[Codificación]
Las fórmulas pueden codificarse usando números naturales.

Las demostraciones también.

\end{prop}

Para llevar a cabo estas codificaciones debemos definir símbolos del lenguaje $n \in \nat$ y asociar a cada variable $v_i$ el número $n(v_i)=2i$ con lo que empleamos sólamente números pares.

Una vez tenemos esto podemos asignar a las operaciones los números impares como sigue:
\[n(\top) = 1, \ \ n(\perp)=3, \ \ n(\neg) = 5, \ \ n(\Or) = 7, \ \ n(\y)=9, \ \ n(=)=11\]
\[n(\exists)=13, \ \ n(\forall) =15, \ \ n('(')=17, \ \ n(')')=19, \ \ n(0)=21, \ \ n(S_1)=23\]
\[n(+_1)=25, \ \ n(\cdot_1)=27, \ \ n(<_1) = 29\]

El problema que nos deriva de esta codificación es que no es claro cómo descifrar el predicado ``230'' puesto que puede interpretarse como el símbolo asociado al 23 seguido de la variable asociada al 0, o como la variable asociada al 2 seguida de la variable asociada al 15, etc.

Empleamos la factorización única para resolver este problema. Para ello definimos la función primo($K$) que nos devuelve el primero que ocupa la posición $K+1$.

Así el número de Godel de una palabra se calcula como:
\[g(u_0,u_1,...,u_k)=2^{n(u_0)}\times 2^{n(u_1)}\times ... \times \text{primo}(k)^{n(u_k)}\]

De esta forma, al leer el número asociado a una fórmula basta con factorizarlo, lo que nos permite obtener la fórmula original de forma unívoca.

%TODO completar. codificacion de vectores usando el dibujito ese que recorre todo.

\begin{defn}[Teoría recursiva]
Una teoría Σ es recursiva si el conjunto de números de Godel
\[\#Σ = \{g(σ) \tq σ \in Σ\}\]
es recursivo.
\end{defn}

Esto nos dice que, dada cualquier σ, podemos decidir algorítmicamente si $σ \in Σ$ ó $σ \in Σ^c$.

\begin{defn}[Teoría de Σ (Teor(Σ))]
Al conjnto de teoremas de Σ se le denomina Teoría de Σ.
\[\text{Teor}(Σ) = \{σ \tq Σ \vdash σ\}\]
Definimos también
\[\#\text{Teor}(Σ)=\{g(σ)\tq Σ \vdash σ\}\]
\end{defn}

\begin{defn}[Teoría deducible]
Decimos que Σ es deducible si $\#\text{Teor}(Σ)$ es recursiva, es decir, existe un algoritmo que dado cualquier σ nos dice es un teorema o no.
\end{defn}

\begin{example}
Podemos comprobar que el caso $Σ = \emptyset$ es recursiva de manera trivial.

También puede verse que $\underline{N}$ es recursiva.
\end{example}

\obs Cualquier teoría finia es recursiva.

\begin{theorem}
La lógica proposicional es deducible.

De hecho, puede demostrarse que el conjunto de los números de Goedel de las tautologías, es decir $\{g(p) \tq p \text{ es tautología}\}$, es recursivo primitivo.
\end{theorem}

\begin{theorem}
El conjunto de axiomas de la lógica de primer orden es recursivo (de hecho es recursivo primitivo).
\end{theorem}

\begin{theorem}
Sea Σ una teoría recursiva, el conjunto:
\[\text{Dem}(Σ)=\{(m,n)\tq m=g(σ) \text{ y } n=g(\text{alguna demostración formal de σ})\}\]
es recursivo.
\end{theorem}
\begin{proof}
Para llevar a cabo esta demostración nos basta con encontrar un algoritmo que nos permita determinar si el par de valores (m,n) pertecene, o no, a Dem(Σ). Para ello tendremos que descodificar $m$ y $n$.

Si $g^{-1}(m)=σ$ y $g^{-1}(n)$ es una demostración de σ, entonces $(m,n)\in \text{Dem}(Σ)$.

En caso contrario $(m,n)\in \text{Dem}(Σ)$.
\end{proof}

\obs Como $\ind_{\text{Dem}(Σ)}$ es una función recursiva total, existe una fómula en el lenguaje formal, digamos $\varphi_{\text{Dem}(Σ)}$, que la representa.

Puede demostrarse que las proyecciones sobre las coordenadas de conjuntos recursivos son recursivamente enumerables.

\begin{corol}
Si una teoría es recursiva entonces el conjunto de sus teoremas es recursivamente enumerable, es decir, existe un algoritmo que encuentra todos los toeremas de Σ.
\end{corol}
\begin{proof}
Sabemos que la proyeccion sobre los ejes de un conjunto recursivo es recursivamente enumerable por lo que:
\[π\left(\ind_{\text{Dem}(Σ)}\right) \text{ es recursivamente enumerable}\]

que es justo lo que necesitamos probar.
\end{proof}

\begin{corol}
Si Σ es recursiva y completa entonces es decidible.
\end{corol}
\begin{proof}
Como $\#\text{Teor}(Σ)$ es recursivamente enumerable, basta probar que su complementario es recursivamente enumerable.

Dada σ, enunciamos los teoremas de Σ sistematicamente. Como Σ es completa, tras un número finito de pasos aparecerá σ o $\neg σ$.
\end{proof}