\chapter{Algoritmos de factorización y tests de primalidad}

La base de la seguridad del sistema RSA es el hecho de que es fácil generar números primos grandes (por eso podemos usar el algoritmo) pero factorizar números grandes en factores primos es muy difícil.

A día de hoy, los ordenadores cuánticos serían capaces de factorizar primos a gran velocidad. En el momento en que estos ordenadores sean bastante grandes (con suficiente memoria) para operar con grandes números, el proceso de factorización será muy rápido, con lo que el algoritmo RSA dejará de ser seguro.

No obstante, vamos a seguir estudiando los procesos de factorización y primalidad desde el punto de vista de los ordenadores y los medios actuales.

Si quisiésemos factorizar un número, empleamos el algoritmo que usábamos en el colegio en el que vamos probando con todos los números primos. Es decir, empleamos la \textbf{criba de Eratóstenes}.

Para hacer esto, necesitamos tener una lista de todos los primos hasta $\sqrt{n}$ con los que ir probando. 

\begin{theorem}[Teorema del número primo]
El número de primos menores que un número $x$ es:
\[π(x) = O\left( \frac{x}{\log(x)}\right)\]
\end{theorem}

Una vez tenemos el número de primos existentes (cosa que en una situación real no se tiene pues $n$ es enorme), tendríamos que hacer un total $π(x)$ divisiones y, puesto que cada divisón nos supone $O(\log^3(n))$ bit-operaciones, tenemos que el total del algoritmo nos supone:
\[O(\log^3(n))\cdot O\left(\frac{\sqrt{n}}{\log(\sqrt{n})}\right) = O\left( e^{\frac{1}{2}\log(n)}\log^2(n)\right) \text{ operaciones }\]

\begin{example}
Supongamos que queremos factorizar un número del orden de $10^{75}$ empleando el ordenador mas rápido del punto.

El ordenador mas rápido del punto es capaz de realizar 33,86 PETAFLOPS, es decir, realizar un total de $33.86 \cdot 10^{15}$ operaciones por segundo.

Puesto que un año tiene $3,1537 \cdot 10^{7}$ segundos, tenemos que en un año podemos realizar, \textbf{con el ordenador más potente del mundo} un total de $10^{24}$ operaciones.

Suponiendo que cada división es una operación (que no es así), necesitaremos $10^{50}$ años para poder factorizar el número $10^{75}$.
\end{example}

\section{Test de primalidad}

Si queremos comprobar si un número es primo, no podemos depender de la factorización del mismo, puesto que entonces no podríamos comprobar la primalidad de números grandes. Para hacerlo nos apoyamos en el siguiente teorema.

\begin{theorem}[Teorema de Wilson (1770)]
\[n \text{ es primo } \iff (n-1)! = -1 \mod n\]
\end{theorem}
\begin{proof}
\begin{itemize}
\item $\Longleftarrow$

Supongamos que $n$ no es primo. Entonces tenemos difernetes casos: 
\begin{enumerate}
\item $n=n_1n_2$ con $1<n_1<n_2<n$

En este caso tenemos 
\[(n-1)!=1\cdot 2 ... \cdot n_1 \cdot ... n_2 \cdot ... = 0 \mod n\]

\item $n=p^2$ siendo $p$ primo impar

En este caso tenemos
\[(n-1)! = 1 \cdot 2 ... \cdot p ... \cdot 2p ... \cdot (n-1) = 0 \mod n\]

\item $n=4=2^2$

En esta ocasión
\[3! = 6 = 2 \mod 4\]
\end{enumerate}

\item $\implies$

Dado un elemento $a\in \ent_n$ tenemos:
\[a=a^{-1} \mod n \iff a^2 = 1 \mod n \iff a^2-1 = m \mod n\]

y la ecuación $a^2-1=0\mod n$ tiene, como mucho, dos raíces en un cuerpo. 

En este caso, estas raíces serían $a=1$, $a=(n-1)$.

Por tanto, puesto que estamos en $\ent_p$, todo elemento tiene su inverso por lo que al escribir $(n-1)!$ estamos multiplicando todos los elementos del cuerpo, por lo que cada factor tendrá estará multiplicado por su inverso y se cancelará, excepto $1$ y $(n-1)$ que son sus propios inversos.

Así nos queda:
\[(n-1)! \mod n = 1 \cdot (n-1) \mod n = n-1 \mod n = -1 \mod n\]
\end{itemize}
\end{proof}

Este algoritmo, aunque parece ``muy bonito'' no vale para nada, puesto que no factoriza (por tanto aporta menos información que la criba de Eratóstenes) y requiere calcular factoriales, lo que es muy costoso.

Sin embargo, en 2002 se desarrolló un algoritmo (AKS) capaz de comprobar si un número es primo en tiempo $O\left( \log^{12}(\log\log(n)^2\right)= \tilde{O}(\log^7(n))$.

Años más tarde, en 2006, se desarrolló un algoritmo capaz de hacer esto mismo en tiempo $\tilde{O}\left( \log^6(n)\right)$

Sin embargo, con el tamaño de números que trabajamos, el algoritmo AKS no es rentable, puesto que las constantes asociadas a la $O$ son demasiado elevadas.

\subsection{Tests probabilísticos}

Estos tests se basan en la afirmación filosófica de E. GJorel, que dice: ``Un suceso cuya probabilidad es de $10^{-50}$ o bien es imposible o nunca será observado''

Así estos test buscarán números que serán primos con probabilidad $1-10^{-50}$. Para esto necesitamos observar alguna propiedad de los números primos que sea fácilmente comprobable, para lo que emplearemos el pequeño teorema de Fermat.

\begin{theorem}[Pequeño teorema de Fermat]
Existen dos versiones de este teorema:
\begin{enumerate}
\item 
\[p \text{ primo } \implies \forall a \in \ent_p \ a^p=a \mod p\]

\item
\[p \text{ primo } \implies \forall a \in \ent_p \ a^{p-1}=1 \mod p\]
\end{enumerate}
\end{theorem}

\begin{defn}[Número pseudoprimo en base $a$]
Decimos que un número $p$ es pseudoprimo en base $a$ si se cumple que
\[a^{p-1}=1 \mod p \]
\end{defn}

Una vez visto esto podemos ver el lema en que se basan los test probabilísticos.
\begin{lemma}
Si existe $b_0$ coprimo con $n$ tal que $b_0^{n-1}\neq 1 \mod n$ (es decir, tenemos una prueba de que $n$ no es primo), entonces $b^{n-1} \neq 1 \mod n$ para, \textbf{al menos la mitad} de los $b$ posibles en $[1,n-1]$ coprimos con $n$.
\end{lemma}

Con este lemma, si $n$ no es primo, entonces $b^{n-1} \neq 1 \mod n$ con probabilidad mayor que $\frac{1}{2}$. Por tanto, si tomo al azar 200 valores $b$ y todos pasan el test, la probabilidad de que el número sea compuesto es menor que $\left( \frac{1}{2}\right)^{200} \approx \left(\frac{1}{10}\right)^{60}$

Veamos la demostración del lemma
\begin{proof}
Consideramos el conjunto de valores $\{a_1,...1_r\} \subset \left(\ent_n\right)^*$ tales que 
\[a_i^{n-1} = 1 \mod n\]

Entonces $n$ no es pseudoprimo en la bases $\{b_0a_1,...,b_0a_r\}$ ya que 
\[(b_0a_i)^{n-1} = b_0^{n-1}a_i^{n-1} = b^{n-1} \neq 1 \mod n\]
\end{proof}

Vamos a ver ahora cómo podríamos construir un test probabilístico de primalidad de manera incremental.

Empezamos considerando una versión \textbf{beta} del test.
\begin{enumerate}
\item Considero un número al azar $b \in [2,n-1]\cap \ent$
\item Compruebo si $b$ es coprimo con $n$ que, como ya vimos, es una tarea \textbf{fácil}
\begin{itemize}
\item Si $b$ no es coprimo con $n$ entonces $n$ no es primo, obviamente
\item Si $b$ es coprimo con $n$ calculo $b^{n-1} \mod n$ que también vimos que era una tarea \textbf{fácil}
\end{itemize}
\item Compruebo si $b^{n-1}$ es coprimo con $n$.
\begin{itemize}
\item Si $b^{n-1}\neq 1 \mod n$ entonces $n$ no es primo.
\item Si $b^{n-1} = 1 \mod n$ entonces $n$ podría ser primo. Volvemos al paso 1.
\end{itemize}
\end{enumerate}

Tras repetir el procedimiento 200 veces, si resulta que $n$ es pseudoprimo en las 200 bases, concluimos que $n$ es, \textbf{probabilísticamente primo}

Sin embargo, esta versión tiene un problema: \textbf{¿Qué ocurre si $n$ es pseudoprimo en todas las bases?}.

\subsection{Números de Carmichael}

\begin{defn}[Número de Carmichael]
Un \textbf{número de Carmichael} es un número compuesto tal que $b^{n-1}=1 \mod n$ para todo $b$ coprimo con $n$.
\end{defn}

Lo que nos interesa es comprobar si existen números de Carmichael (evidentemente existen, pues de lo contrario no hablaríamos de ellos), ver cuántos son y si existe alguna forma útil de caracterizarlos.

\begin{theorem}[Teorema de Korset (1899)]
Sea $n \in \ent$ son equivalentes:
\begin{enumerate}
\item \[b^n=b \mod n \ \forall b \in \ent\]
\item \[b^{n-1} = 1 \mod n \ \forall b \in \ent, \ t.q. \ (b,n)=1 \]
\item n es libre de cuadrados, es decir:
\[a^2|n \implies a = \pm 1 \text{ si p es primo } \neg p^2 | n\]
O lo que es lo mismo, si $p$ es primo y $p$ divide a $n$ entonces $p-1$ divide a $n-1$
\end{enumerate}
\end{theorem}

\begin{proof}
\begin{itemize}
\item $1 \implies 2$

Sabemos que $(b,n)=1 \iff b \in\left(\ent_n\right)^*$. Por tanto, podemos multiplicar a ambos lados de la ecuación por $b^{-1}$ obteniendo:
\[b^n = b \mod n \implies b^{n-1}=1 \mod b\]

\item $3 \implies 1$

Sabiendo que $n$ es libre de cuadrados tenemos que:
\[b^n = b \mod n \iff b^n = b \mod p \ \forall p|n\]

\begin{proof}
Si $p|n$ entonces 
\[b^n = b \mod p \iff 0^n=0 \mod p \]

Por otro lado:
\[(b,p)=1 \implies b^n=bb^{n-1} = bb^{(p-1)k}=b\left(b^{p-1}\right)^k=b\mod p\]
\end{proof}

\item $2 \implies 3$

\begin{itemize}
\item[a)] Supongamos que $n$ no es libre de cuadrados, es decir, supongamos que existe un primo $p$ tal que $n=p^rn'$ siendo $r>2$ y $(n',p)=1$.

En estas condiciones tenemos
\[\left| \left(\ent_n\right)^*\right| = \varphi(p^r)=p^{r-1}(p-1) \implies p|\varphi(p^r)\]
donde la última implicación es válida puesto que $r>2$

Sabemos, por el teorema de Cauchy, que
\[\exists a \in \left(\ent_{p^r}\right)^* \tq ord(a)=p \text{ es decir } \left\{\begin{array}{l}a\neq 1 \mod p^r \\ a^p=1 \mod p^r \end{array}\right.\]

Por el teorema chino del resto, sabemos que existe un elemento $b \in \ent_n$ tal que:
\[\left\{\begin{array}{l}b=a\mod p^r \\ b=1 \mod n' \end{array}\right.\]

Por hipótesis tenemos que $b^{n-1}=1 \mod n$, por tanto:
\[b^{n-1} = 1 \mod p^r = a^{n-1} = 1 \mod p^r \implies ord(a) =p|n-1\]

\item[b)]
Tras llegar a la contradicción del apartado anterior sabemos que $n=p_1...p_r$ con $p_i \neq p_j$. Sea $p | n$ entonces $n=pn'$ con $(n',p)=1$.

Sabemos entonces que $(\ent_p)^*=<a>$ es cíclico.

Por el teorema chino del resto sabemos que 
\[\exists b \in (\ent_p)^* \tq \left\{\begin{array}{l}b=a\mod p \\ b=1 \mod n \end{array}\right.\] 

Si $n-1 = q(p-1)+r$ con $0 < r < p-1$ tenemos que $b^{n-1}=1 \mod n$ lo que implica que
\[b^{n-1}=1 \mod p \implies a^{n-1} = 1 \mod p \implies (a^{p-1})^qa^r = 1 \mod p \implies\]
\[\implies a^p = 1 \mod p \implies ord(a) = (p-1)|r<p-1 \implies r=0\implies p-1 | n-1\]
\end{itemize}
\end{itemize}
\end{proof}
