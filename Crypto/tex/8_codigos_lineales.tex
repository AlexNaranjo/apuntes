\chapter{Códigos lineales}
\section{¿Por qué códigos lineales?}
Como ya se ha observado en el capítulo anterior hay una gran ventaja en el empleo de códigos lineales y es que la distancia mínima puede calcularse de forma mucho más sencilla, pues podemos calcular los pesos de cada palabra para luego tomar el mínimo en lugar de calcular todas las distancias entre posibles pares de palabras antes de tomar el mínimo.

Otra ventaja de los códigos lineales es que a la hora de definirlos no es necesario listar todas las palabras que componenen el código sino que basta con dar una base del espacio lineal que define el código.

Esta ventaja también se puede aprovechar proporcionando las ecuaciones que definen el código, de nuevo sin tener que listar todas las palabras del mismo. No obstante se tendrán que proporcionar más ecuaciones que elementos de la base aunque en cualquier caso estamos teniendo que redactar muchísima menos información que si diésemos todas las palabras válidas.

Por último, pero no por ello menos improtante, otra ventaja de los códigos lineales es que existen algoritmos rápidos de codificación y descodificación.

No obstante, los códigos lineales también tienen algunas \textbf{desventajas}. En general los códigos lineales son ``mejores'' que los demás aunque esto no siempre es así y nos encontraremos con excepciones en las que es mejor emplear códigos no lineales.

\begin{defn}[.$(n,k,d)$-código q-nario]
Un $[n,k,d]$-código lineal q-nario es un subespacio vectorial $\algb{C} \subset F_q^n$ tal que $dim(\algb{C})=k$ y $d(\algb{C})=d$.
\end{defn}

\begin{defn}[B$_q(n,d)$]
\[B_q(n,d)=max \{q^k \tq \ \exists [n,k,d]\text{-código linea q-nario}\}\]
\end{defn}

\obs $B_q(n,d)\leq A_q(n,d)$ y en ocasiones se tiene la desigualdad escrita.

\begin{defn}[Matriz generadora]
Sea $\algb{C}$ un [n,k,d]-código lineal q-nario decimos que una matriz $M$ es generadora de $\algb{C}$ si y sólo si las filas de $M$ son una base de $\algb{C}$.

Esta matriz deberá ser de dimensión $k\times n$.
\end{defn}

Decimos que $H \in \text{Mat}(F_q)$ será \concept{matriz controladora de paridad} para $\algb{C}$ si dado $x\in F_q^n$ se cumple
\[x \in \algb{C} \iff Hx^t = 0 \]

\begin{example}
Consideramos el código $Ham(3,2)$ como se ha definido anteriormente. En este caso tendremos:
\[H = \left(\begin{array}{ccccccc}
1 & 1 & 1 & 0 & 0 & 0 & 1\\
1 & 1 & 0 & 1 & 0 & 1 & 0\\
1 & 0 & 1 & 1 & 1 & 0 & 0
\end{array} \right), \ \ G=\left(\begin{array}{ccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 1\\
0 & 1 & 0 & 0 & 0 & 1 & 1\\
0 & 0 & 1 & 0 & 1 & 0 & 1\\
0 & 0 & 0 & 1 & 1 & 1 & 0
\end{array}\right) \]
\end{example}

\begin{prop}\label{prop:At-At}
Si la matriz generadora puede escribirse como la matriz identidad complementada con algo, es decir:
\[G=[I_k \ | \ A_{k \times (n-k)}]\]
entonces podemos tomar
\[H = [-A^t_{(n-k) \times k} \ | \ I_{n-k}]\]
donde $k$ es la dimensión del código e $I$ es la matriz identidad.
\end{prop}

\obs Queda como ejercicio para el lector la comprobación trivial de que $HG^t=0$

\textcolor{red}{Malvado, completa la demostración que debería ir aquí}


\obs Las siguientes operaciones en $G$ o en $H$ no cambian el código:
\begin{enumerate}
\item Intercambiar dos filas
\item Multiplicar una fila por un $λ\in F_q$ no nulo.
\item Sumar a una fila un múltiplo de otra
\end{enumerate}

\begin{defn}[Códigos lineales equivalentes]
Dos códigos lineales son equivalentes si uno se obtiene del otro a partir de una combinación de las siguientes operaciones
\begin{enumerate}
\item Intercambiar dos variables.

Esta operación se traduce en intercambiar dos columnas en las matrices $G$ o $H$.

\item Multiplicar los símbolos de la variable $x_i$ por $λ \in F_q$ no nulo.

Esta operación se traduce en multiplicar toda una columna de $G$ por λ o una columna de $H$ por $\frac{1}{λ}$.
\end{enumerate}
\end{defn}

\begin{example}
Dado el código $Ham(3,2)$, del que hemos hallado las matrices $G$ y $H$ en el ejemplo anterior, podemos ver que la matriz
\[\tilde{H} = \left(\begin{array}{ccccccc}
0 & 0 & 0 & 1 & 1 & 1 & 1\\
0 & 1 & 1 & 0 & 0 & 1 & 1\\
1 & 0 & 1 & 0 & 1 & 0 & 1
\end{array} \right)\]
define el mismo código.
\end{example}

Podemos observar que la matriz $H$ tiene 7 columnas y todas son distintas y de longitud 3. Por tanto está considerando todas las posibles combinaciones de tres bits (sin contar la combinación ``000'') lo que nos garantiza que cualquier matriz que satisfaga esta propiedad definirá el mismo código.

\begin{prop}
Todo código lineal es equivalente a otro de la forma:
\[G=[I \ |\  A ], , H = [-A^t \ | \ I]\]
este formato se denomina \concept{notación estándar}
\end{prop}

\begin{proof}
La idea es que siempre podemos aplicar Gauss forzando a tener columnas que sólo tengan un elemento no nulo.

Una vez tenemos esto, si estas columnas no están formando la matriz identidad, siempre podemos intercambiar columnas para obtener esta matriz.

Para garantizar la presencia de $A^t$ y $-A^t$ nos apoyamos en la propisición \ref{prop:At-At}
\end{proof}

\section{Codificación con códigos lineales}
Tenemos que, por lo visto en la sección anterior, la matriz $G$ tiene dimensión $k \times n$. Sea
\[G = \left(\begin{array}{l}g_1\\g_2\\...\\g_k\end{array}\right)\]

A partir de esta matriz podemos deducir el código:
\[\algb{C} = \left\{\sum_{i = 1}^k λ_ig_i \tq λ_i \in F_q \right\}\]

La forma de codificar pasará por emplear una función de la forma
\[\appl{f}{F_q^k}{\algb{C}}\]
Si tenemos que el código es lineal y está en su forma estándar tenemos que las primeras $k$ cifras del código codificado coinciden con el mensaje original, de modo que la decodificación es trivial.

\section{Decodificación con códigos lineales}
TODO
